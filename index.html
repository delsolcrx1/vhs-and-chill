<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Room Simulator</title>
    <link rel="icon" type="image/x-icon" href="public/img/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.emulatorjs.org/stable/data/css/emu.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            font-family: 'VT323', monospace;
            background-color: #111;
            color: #eee;
            overflow: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #222;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #00ff00;
        }

        .crt-overlay {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .range-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #333;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }

        .range-slider:hover {
            opacity: 1;
        }

        .range-slider:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff00;
            cursor: pointer;
            border-radius: 0;
        }

        .range-slider:disabled::-webkit-slider-thumb {
            background: #555;
            cursor: not-allowed;
        }

        /* Number Input Styling */
        .num-input {
            background: #222;
            border: 1px solid #444;
            color: #00ff00;
            font-family: 'VT323', monospace;
            width: 45px;
            text-align: right;
            font-size: 14px;
            padding-right: 2px;
        }

        .num-input:focus {
            outline: none;
            border-color: #00ff00;
        }

        #tv-container {
            transition: width 0.3s, height 0.3s;
        }

        .control-panel {
            backdrop-filter: blur(10px);
            background-color: rgba(0, 0, 0, 0.85);
            border-right: 2px solid #333;
            transition: transform 0.3s ease-in-out;
        }

        .control-panel.hidden-panel {
            transform: translateX(-100%);
        }

        .toggle-btn {
            transition: all 0.2s;
        }

        .toggle-btn.active {
            background-color: #00ff00;
            color: #000;
            box-shadow: 0 0 10px #00ff00;
        }

        /* Remote Control Styling */
        #remote-panel {
            border-left: 2px solid #333;
            background-color: #1a1a1a;
            /* slightly lighter than pure black for plastic feel */
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.8);
            transform: translateX(100%);
        }

        #remote-panel.visible-panel {
            transform: translateX(0);
        }

        .remote-btn {
            background: #2a2a2a;
            border: 2px solid #111;
            border-bottom: 4px solid #111;
            border-right: 4px solid #111;
            color: #ccc;
            border-radius: 4px;
            transition: all 0.1s;
            text-transform: uppercase;
            font-family: 'VT323', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .remote-btn:active {
            transform: translate(2px, 2px);
            border-bottom: 2px solid #111;
            border-right: 2px solid #111;
        }

        .remote-btn-power {
            background: #d00;
            color: #fff;
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
        }

        .remote-btn-power.on {
            background: #0d0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        .remote-group {
            background: #222;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #333;
        }

        .remote-label {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }

        /* Helper for TV Layering */
        .tv-layer-front {
            z-index: 50 !important;
            /* Above canvas */
        }

        .tv-layer-back {
            z-index: 10 !important;
            /* Below canvas */
        }

        /* Selection Box Styling */
        #selection-box {
            border: 2px dashed #ff0000;
            background-color: rgba(255, 0, 0, 0.2);
            position: absolute;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        .cursor-crosshair {
            cursor: crosshair !important;
        }

        /* File input override styling */
        .custom-file-input::-webkit-file-upload-button {
            visibility: hidden;
            width: 0;
        }

        .custom-file-input::before {
            content: 'Load MP3/WAV';
            display: inline-block;
            background: #333;
            border: 1px solid #555;
            padding: 2px 6px;
            outline: none;
            white-space: nowrap;
            cursor: pointer;
            font-size: 10px;
            color: #aaa;
        }

        .custom-file-input:hover::before {
            background: #444;
            color: #fff;
        }

        /* Scanline animation for static */
        @keyframes scan {
            0% {
                transform: translateY(0);
            }

            100% {
                transform: translateY(100vh);
            }
        }

        .synth-controls {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 100px;
            opacity: 1;
            overflow: hidden;
        }

        .synth-controls.hidden-ctrl {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        /* YouTube Container helper to prevent pointer event stealing in chroma mode unless necessary, 
           though we mostly control via API */
        .yt-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Keep interactions on our UI */
        }

        /* EmulatorJS scaling - ensure it works at any size */
        #emulator-container {
            width: 100% !important;
            height: 100% !important;
            overflow: hidden;
            /* clean edges */
        }

        #game {
            width: 100% !important;
            height: 100% !important;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        /* Force children (canvas/iframe) to fit */
        #game canvas,
        #game iframe,
        #game .ejs-container {
            max-width: 100% !important;
            max-height: 100% !important;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain !important;
            transform: none !important;
            /* reset any internal scaling that might offset */
        }

        /* Dial-up Overlay */
        .dialup-overlay {
            background-color: #c0c0c0;
            border: 2px outset #fff;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.5);
            font-family: 'MS Sans Serif', 'Arial', sans-serif;
            color: #000;
        }

        .dialup-header {
            background: linear-gradient(90deg, #000080, #1084d0);
            color: white;
            padding: 2px 4px;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Retro Browser */
        .browser-toolbar {
            background: #d4d0c8;
            border-bottom: 2px solid #808080;
            padding: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: sans-serif;
        }

        .browser-btn {
            border: 1px outset #fff;
            background: #d4d0c8;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            color: black;
        }

        .browser-btn:active {
            border: 1px inset #fff;
        }

        .browser-address {
            background: white;
            border: 1px inset #808080;
            padding: 2px;
            font-family: monospace;
            font-size: 12px;
            flex-grow: 1;
            color: black;
        }

        /* Scaled Iframe for Zoom Out Effect */
        #browser-frame {
            width: 200%;
            height: 200%;
            transform: scale(0.5);
            transform-origin: 0 0;
            border: none;
        }
    </style>
    <!-- Load YouTube API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- EmulatorJS will be loaded dynamically when a game is selected -->
</head>

<body class="h-screen w-screen flex relative">

    <!-- Sidebar Controls -->
    <div id="sidebar"
        class="control-panel absolute z-50 h-full w-[480px] flex flex-col p-4 overflow-y-auto left-0 top-0">
        <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-2">
            <h1 class="text-3xl text-green-500 tracking-wider">RETRO SIM v1.5</h1>
            <div class="flex gap-2">
                <button id="save-config-btn"
                    class="text-sm bg-blue-900 px-2 py-1 rounded text-white hover:bg-blue-700 border border-blue-800">SAVE</button>
                <button id="hide-menu-btn" class="text-gray-400 hover:text-white">
                    <i class="fas fa-chevron-left"></i>
                </button>
            </div>
        </div>

        <!-- Format -->
        <div class="mb-6">
            <h2 class="text-lg text-green-400 mb-2 border-b border-gray-800 pb-1">DISPLAY FORMAT</h2>
            <div class="flex gap-2">
                <button onclick="setRatio('16:9')"
                    class="flex-1 bg-gray-800 py-2 hover:bg-gray-700 border border-gray-600 text-base">16:9
                    (TV)</button>
                <button onclick="setRatio('9:16')"
                    class="flex-1 bg-gray-800 py-2 hover:bg-gray-700 border border-gray-600 text-base">9:16
                    (MOBILE)</button>
            </div>
        </div>

        <!-- Video Uploads -->
        <div class="mb-6">
            <h2 class="text-xl text-green-400 mb-2 border-b border-gray-800 pb-1">VIDEO SOURCES</h2>

            <div class="mb-4">
                <label class="block text-gray-400 text-base mb-1">1. Room (Background)</label>
                <input type="file" id="room-upload" accept="video/*,image/*"
                    class="w-full text-base text-gray-500 file:mr-2 file:py-1 file:px-2 file:border-0 file:text-sm file:font-semibold file:bg-green-900 file:text-green-100 hover:file:bg-green-700" />
            </div>

            <!-- Method Selection -->
            <div class="mt-4 border-t border-gray-800 pt-2">
                <label class="block text-green-400 text-base mb-2">PLACEMENT METHOD</label>
                <div class="flex flex-col gap-2">
                    <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                        <input type="radio" name="place-method" value="chroma" checked class="accent-green-500">
                        <span>Chroma Key (Green Screen)</span>
                    </label>
                    <label class="flex items-center gap-2 text-sm text-gray-300 cursor-pointer">
                        <input type="radio" name="place-method" value="manual" class="accent-green-500">
                        <span>Manual Selection (Draw Box)</span>
                    </label>
                </div>
            </div>

            <!-- Chroma Controls -->
            <div id="chroma-controls" class="mt-3 bg-gray-900 p-2 rounded border border-gray-800">
                <div class="text-xs text-green-500 uppercase tracking-widest mb-1">Green Screen Settings</div>
                <div class="flex justify-between mt-1">
                    <div class="text-sm text-gray-500">Threshold</div>
                    <div class="text-sm text-gray-300" id="val-chroma-thresh">90</div>
                </div>
                <input type="range" id="chroma-threshold" min="0" max="200" value="90" class="range-slider mt-1">

                <div class="flex justify-between mt-2">
                    <div class="text-sm text-gray-500">Softness</div>
                    <div class="text-sm text-gray-300" id="val-chroma-soft">20</div>
                </div>
                <input type="range" id="chroma-softness" min="0" max="100" value="20" class="range-slider mt-1">
            </div>

            <!-- Manual Transform Controls -->
            <div id="transform-controls" class="mt-3 bg-gray-900 p-2 rounded border border-gray-800">
                <div class="text-xs text-blue-400 uppercase tracking-widest mb-1 flex justify-between items-center">
                    <span>Transform</span>
                    <div class="flex items-center gap-2">
                        <label class="flex items-center gap-1 cursor-pointer select-none">
                            <input type="checkbox" id="lock-manual" class="accent-red-500 w-3 h-3">
                            <span class="text-[10px] text-gray-500 uppercase">LOCK</span>
                        </label>
                        <span id="manual-hint" class="hidden text-red-400 animate-pulse text-[10px]">DRAG!</span>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <div class="text-sm text-gray-500">Scale</div>
                        <input type="range" id="tv-scale" min="0.1" max="2" step="0.05" value="1" class="range-slider">
                    </div>
                    <div>
                        <div class="text-sm text-gray-500">Rotation</div>
                        <input type="range" id="tv-rotate" min="-45" max="45" value="0" class="range-slider">
                    </div>
                    <div>
                        <div class="text-sm text-gray-500">Pos X</div>
                        <input type="range" id="tv-x" min="-100" max="100" value="0" class="range-slider">
                    </div>
                    <div>
                        <div class="text-sm text-gray-500">Pos Y</div>
                        <input type="range" id="tv-y" min="-100" max="100" value="0" class="range-slider">
                    </div>
                </div>
            </div>
        </div>


        <!-- Advertising Settings -->
        <div class="mb-6">
            <h2 class="text-xl text-green-400 mb-2 border-b border-gray-800 pb-1">SIMULATION (ADS)</h2>
            <div class="flex justify-between items-center bg-gray-900 p-2 rounded border border-gray-800">
                <span class="text-base text-gray-300">Ads per Break</span>
                <div class="flex items-center gap-2">
                    <button id="btn-ads-toggle"
                        class="toggle-btn w-3 h-3 rounded-full border border-gray-600 bg-gray-800 mr-1"
                        title="Enable/Disable Ads via Config"></button>
                    <input type="number" id="ads-count" min="0" max="10" value="2"
                        class="bg-gray-800 border border-gray-700 text-white text-sm w-12 p-1 text-center rounded focus:outline-none focus:border-green-500">
                </div>
            </div>
            <div class="flex justify-between items-center text-xs text-gray-500 mt-1 px-1">
                <span>Configured Playlists: <span id="ads-playlist-count">0</span></span>
                <button onclick="if(confirm('Clear all ad play counts?')) resetAdCounts()"
                    class="text-xs text-red-500 hover:text-red-400 hover:underline">Reset Counts</button>
            </div>
        </div>

        <!-- Visual Effects -->
        <div class="mb-6">
            <h2 class="text-xl text-green-400 mb-2 border-b border-gray-800 pb-1">VISUAL EFFECTS</h2>

            <!-- CRT Effects -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-base text-gray-300">CRT Overlay</span>
                    <button id="btn-crt"
                        class="toggle-btn active w-4 h-4 rounded-full border border-gray-600 bg-gray-800"></button>
                </div>
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs text-gray-500">Scanline Intensity</label>
                        <span id="val-crt-int" class="text-xs text-gray-400">30%</span>
                    </div>
                    <input type="range" id="crt-intensity" min="0" max="1" step="0.05" value="0.3"
                        class="range-slider mb-2">

                    <div class="flex gap-2 text-xs text-gray-400">
                        <label
                            class="flex items-center gap-1 bg-black px-2 py-1 rounded border border-gray-700 flex-1 justify-center cursor-pointer">
                            <input type="radio" name="crt-scope" value="screen" checked class="accent-green-500"> Screen
                        </label>
                        <label
                            class="flex items-center gap-1 bg-black px-2 py-1 rounded border border-gray-700 flex-1 justify-center cursor-pointer">
                            <input type="radio" name="crt-scope" value="tv" class="accent-green-500"> TV Only
                        </label>
                    </div>
                </div>
            </div>

            <!-- TV Post-Processing -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="text-xs text-blue-400 uppercase tracking-widest mb-2">TV Post-Processing</div>

                <div class="grid grid-cols-2 gap-2">
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Brightness</label>
                        </div>
                        <input type="range" id="fx-bright" min="0" max="2" step="0.05" value="1" class="range-slider">
                    </div>
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Contrast</label>
                        </div>
                        <input type="range" id="fx-contrast" min="0" max="2" step="0.05" value="1" class="range-slider">
                    </div>
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Saturation</label>
                        </div>
                        <input type="range" id="fx-sat" min="0" max="3" step="0.05" value="1" class="range-slider">
                    </div>
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Hue</label></div>
                        <input type="range" id="fx-hue" min="0" max="360" step="10" value="0" class="range-slider">
                    </div>
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Blur</label></div>
                        <input type="range" id="fx-blur" min="0" max="10" step="0.5" value="0" class="range-slider">
                    </div>
                    <div>
                        <div class="flex justify-between"><label class="text-xs text-gray-500">Sepia</label></div>
                        <input type="range" id="fx-sepia" min="0" max="1" step="0.05" value="0" class="range-slider">
                    </div>
                </div>
                <button id="reset-fx"
                    class="mt-2 w-full text-xs bg-gray-800 hover:bg-gray-700 py-1 rounded text-gray-400">RESET VIDEO
                    FX</button>
            </div>
        </div>

        <!-- Audio Mixer -->
        <div class="mb-6 flex-1">
            <h2 class="text-xl text-green-400 mb-2 border-b border-gray-800 pb-1">AUDIO MIXER <button id="audio-init"
                    class="text-sm bg-red-900 px-2 rounded ml-2">START AUDIO</button></h2>

            <!-- TV Audio -->
            <div class="mb-4">
                <div class="flex justify-between items-center mb-1">
                    <span class="text-base text-blue-300">TV Volume</span>
                </div>
                <div class="flex gap-2 items-center">
                    <input type="range" id="vol-tv" min="0" max="1" step="0.01" value="1"
                        class="range-slider mb-1 flex-1">
                    <input type="number" id="vol-tv-num" min="0" max="100" value="100" class="num-input">
                </div>
            </div>

            <!-- Birds -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-base">Birds</span>
                    <button id="btn-birds"
                        class="toggle-btn w-4 h-4 rounded-full border border-gray-600 bg-gray-800"></button>
                </div>
                <div class="flex gap-2 items-center mb-2">
                    <input type="range" id="vol-birds" min="0" max="100" value="50" class="range-slider flex-1">
                    <input type="number" id="vol-birds-num" min="0" max="100" value="50" class="num-input">
                </div>
                <div id="synth-birds" class="grid grid-cols-2 gap-2 mb-2 synth-controls">
                    <div>
                        <label class="text-xs text-gray-500 block">Freq</label>
                        <input type="range" id="freq-birds" class="range-slider">
                    </div>
                    <div>
                        <label class="text-xs text-gray-500 block">Intensity</label>
                        <input type="range" id="int-birds" class="range-slider">
                    </div>
                </div>


                <input type="file" id="file-birds" accept="audio/*"
                    class="custom-file-input w-full text-sm text-gray-600">
            </div>

            <!-- Traffic -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-base">Traffic</span>
                    <button id="btn-car"
                        class="toggle-btn w-4 h-4 rounded-full border border-gray-600 bg-gray-800"></button>
                </div>
                <div class="flex gap-2 items-center mb-2">
                    <input type="range" id="vol-car" min="0" max="100" value="50" class="range-slider flex-1">
                    <input type="number" id="vol-car-num" min="0" max="100" value="50" class="num-input">
                </div>
                <div id="synth-car" class="grid grid-cols-2 gap-2 mb-2 synth-controls">
                    <div>
                        <label class="text-xs text-gray-500 block">Frequency</label>
                        <input type="range" id="freq-car" class="range-slider">
                    </div>
                </div>
                <input type="file" id="file-car" accept="audio/*"
                    class="custom-file-input w-full text-sm text-gray-600">
            </div>

            <!-- Lawnmower -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-base">Lawnmower</span>
                    <button id="btn-mower"
                        class="toggle-btn w-4 h-4 rounded-full border border-gray-600 bg-gray-800"></button>
                </div>
                <div class="flex gap-2 items-center mb-2">
                    <input type="range" id="vol-mower" min="0" max="100" value="50" class="range-slider flex-1">
                    <input type="number" id="vol-mower-num" min="0" max="100" value="50" class="num-input">
                </div>
                <div id="synth-mower" class="grid grid-cols-2 gap-2 mb-2 synth-controls">
                    <div>
                        <label class="text-xs text-gray-500 block">Distance</label>
                        <input type="range" id="dist-mower" class="range-slider">
                    </div>
                </div>
                <input type="file" id="file-mower" accept="audio/*"
                    class="custom-file-input w-full text-sm text-gray-600">
            </div>

            <!-- Talking -->
            <div class="mb-4 p-2 bg-gray-900 rounded border border-gray-800">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-base">Talking</span>
                    <button id="btn-house"
                        class="toggle-btn w-4 h-4 rounded-full border border-gray-600 bg-gray-800"></button>
                </div>
                <div class="flex gap-2 items-center mb-2">
                    <input type="range" id="vol-house" min="0" max="100" value="50" class="range-slider flex-1">
                    <input type="number" id="vol-house-num" min="0" max="100" value="50" class="num-input">
                </div>
                <input type="file" id="file-house" accept="audio/*"
                    class="custom-file-input w-full text-sm text-gray-600">
            </div>
        </div>
    </div>

    <!-- Remote Control Panel -->
    <div id="remote-panel"
        class="control-panel absolute z-50 h-full w-72 flex flex-col p-4 overflow-y-auto right-0 top-0">
        <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-2">
            <h1 class="text-2xl text-green-500 tracking-wider">REMOTE</h1>
            <button id="hide-remote-btn" class="text-gray-400 hover:text-white">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>

        <!-- Source Tabs -->
        <div class="flex gap-1 mb-4 border-b border-gray-700 pb-1">
            <button id="tab-file"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400 active-tab">FILE</button>
            <button id="tab-url"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400">URL</button>
            <button id="tab-channels"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400">CHANNELS</button>
            <button id="tab-games"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400">GAMES</button>
            <button id="tab-web"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400">WEB</button>
            <button id="tab-party"
                class="flex-1 text-xs font-bold py-1 bg-gray-800 hover:bg-gray-700 text-gray-400">PARTY</button>
        </div>

        <!-- TV Source Controls (Moved & Refactored) -->
        <div id="remote-content-area" class="mb-4">
            <!-- FILE TAB -->
            <div id="panel-file" class="block">
                <div class="mb-2 text-center">
                    <input type="file" id="tv-upload" accept="video/*" class="hidden" />
                    <label for="tv-upload"
                        class="cursor-pointer block w-full py-2 bg-blue-900 hover:bg-blue-800 text-white text-sm font-bold rounded border border-blue-700">
                        <i class="fas fa-file-video mr-2"></i> SELECT VIDEO FILE
                    </label>
                </div>
                <div class="text-xs text-gray-500 text-center">Supports MP4, WebM, MKV</div>
            </div>

            <!-- URL TAB -->
            <div id="panel-url" class="hidden">
                <div class="flex gap-1 mb-2">
                    <input type="text" id="yt-url" placeholder="Paste URL..."
                        class="w-full bg-gray-900 border border-gray-700 text-sm p-2 text-white placeholder-gray-600 focus:outline-none focus:border-red-500 rounded">
                    <button id="yt-load-btn"
                        class="bg-red-900 text-white text-sm px-2 hover:bg-red-700 border border-red-800 rounded">GO</button>
                </div>
                <div class="text-xs text-gray-500 text-center">YouTube Videos & Playlists</div>
            </div>

            <!-- CHANNELS TAB -->
            <div id="panel-channels" class="hidden">
                <div id="channels-list" class="flex flex-col gap-2 max-h-96 overflow-y-auto pr-1">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- GAMES TAB -->
            <div id="panel-games" class="hidden">
                <div class="mb-3">
                    <label class="block text-gray-400 text-sm mb-2">SELECT SYSTEM</label>
                    <select id="game-system"
                        class="w-full bg-gray-900 border border-gray-700 text-sm p-2 text-white focus:outline-none focus:border-green-500 rounded">
                        <option value="">-- Choose System --</option>
                        <option value="nes">Nintendo Entertainment System (NES)</option>
                        <option value="segaMD">Sega Genesis / Mega Drive</option>
                    </select>
                </div>
                <div class="mb-2">
                    <input type="file" id="rom-upload" accept=".nes,.smd,.md,.gen,.bin" class="hidden" />
                    <label for="rom-upload"
                        class="cursor-pointer block w-full py-2 bg-purple-900 hover:bg-purple-800 text-white text-sm font-bold rounded border border-purple-700 text-center"
                        id="rom-upload-label">
                        <i class="fas fa-gamepad mr-2"></i> SELECT ROM FILE
                    </label>
                </div>
                <div class="text-xs text-gray-500 text-center mb-2" id="rom-filename">No ROM loaded</div>
                <button id="game-load-btn"
                    class="w-full bg-green-900 text-white text-sm px-3 py-2 hover:bg-green-700 border border-green-800 rounded font-bold disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled>
                    <i class="fas fa-play mr-2"></i>LOAD GAME
                </button>
                <div class="mt-3 text-xs text-gray-600 leading-relaxed">
                    <div class="mb-1"><strong class="text-gray-500">Controls:</strong></div>
                    <div>Arrow Keys = D-Pad</div>
                    <div>Z = A/Button 1</div>
                    <div>X = B/Button 2</div>
                    <div>Enter = Start</div>
                    <div>Shift = Select</div>
                </div>
            </div>
        </div>

        <!-- WEB TAB -->
        <div id="panel-web" class="hidden">
            <div class="mb-3">
                <label class="block text-gray-400 text-sm mb-2">DIAL UP INTERNET</label>
                <input type="text" id="web-url" value="https://www.spacejam.com/1996/" placeholder="http://..."
                    class="w-full bg-gray-900 border border-gray-700 text-sm p-2 text-white placeholder-gray-600 focus:outline-none focus:border-blue-500 rounded mb-2">
                <button id="btn-dialup"
                    class="w-full bg-blue-900 hover:bg-blue-800 text-white text-sm font-bold py-2 rounded border border-blue-700">
                    <i class="fas fa-network-wired mr-2"></i> CONNECT
                </button>
            </div>
            <div class="text-xs text-gray-500 text-center px-2">
                Note: Some modern sites may refuse to load in an iframe (X-Frame-Options).
            </div>
        </div>

        <!-- PARTY TAB -->
        <div id="panel-party" class="hidden">
            <div class="mb-4 text-center">
                <div class="text-xs text-gray-400 mb-2">HOST A PARTY</div>
                <button id="btn-host-party"
                    class="w-full bg-green-900 hover:bg-green-800 text-white text-sm font-bold py-2 rounded border border-green-700 mb-2">
                    CREATE PARTY
                </button>
                <div id="host-code-display"
                    class="hidden bg-black border border-green-500 text-green-500 font-mono text-xl p-2 rounded mb-2 select-all">
                    ------
                </div>
                <div id="host-status" class="text-[10px] text-gray-500">Share code with friends</div>
            </div>

            <div class="border-t border-gray-700 my-4"></div>

            <div class="mb-4 text-center">
                <div class="text-xs text-gray-400 mb-2">JOIN A PARTY</div>
                <input type="text" id="join-code-input" placeholder="ENTER CODE" maxlength="6"
                    class="w-full bg-gray-900 border border-gray-700 text-sm p-2 text-white placeholder-gray-600 focus:outline-none focus:border-blue-500 rounded mb-2 text-center uppercase font-mono">
                <button id="btn-join-party"
                    class="w-full bg-blue-900 hover:bg-blue-800 text-white text-sm font-bold py-2 rounded border border-blue-700">
                    JOIN PARTY
                </button>
                <div id="join-status" class="text-[10px] text-gray-500 mt-2"></div>
            </div>

            <div class="text-[10px] text-gray-600 text-center px-2">
                Syncs video, background, and config. Host controls playback.
            </div>
        </div>

        <!-- Power -->
        <div class="remote-group text-center">
            <div class="remote-label">POWER</div>
            <button id="remote-power" class="remote-btn remote-btn-power w-12 h-12 rounded-full mx-auto on">
                <i class="fas fa-power-off text-xl"></i>
            </button>
        </div>

        <!-- Playback -->
        <div class="remote-group">
            <div class="remote-label">PLAYBACK</div>
            <!-- Video Fit Mode -->
            <div class="flex justify-center mb-2">
                <select id="video-fit"
                    class="bg-black text-xs text-gray-400 border border-gray-700 p-1 w-full rounded text-center">
                    <option value="cover">ZOOM (COVER)</option>
                    <option value="contain">FIT (CONTAIN)</option>
                    <option value="fill">STRETCH (FILL)</option>
                </select>
            </div>
            <div class="flex gap-2 justify-center mb-2">
                <button id="remote-play" class="remote-btn w-10 h-10">
                    <i class="fas fa-play"></i>
                </button>
                <button id="remote-pause" class="remote-btn w-10 h-10">
                    <i class="fas fa-pause"></i>
                </button>
            </div>
            <!-- Seek Bar -->
            <div class="mb-2 px-1">
                <input type="range" id="video-seek" min="0" max="100" value="0" step="0.1" class="range-slider mb-1">
                <div id="video-time" class="text-[10px] text-gray-500 text-center font-mono">00:00 / 00:00</div>
            </div>
            <div class="flex gap-2 justify-center mb-2">
                <button id="remote-prev" class="remote-btn w-10 h-10" title="Prev Video">
                    <i class="fas fa-step-backward"></i>
                </button>
                <button id="remote-next" class="remote-btn w-10 h-10" title="Next Video">
                    <i class="fas fa-step-forward"></i>
                </button>
            </div>
            <div class="flex justify-center">
                <button id="remote-eject" class="remote-btn w-full py-1 text-sm">
                    <i class="fas fa-eject mr-2"></i> EJECT / UNLOAD
                </button>
            </div>
        </div>

        <!-- Volume -->
        <div class="remote-group">
            <div class="remote-label">TV VOLUME</div>
            <div class="flex gap-2 justify-center">
                <button id="remote-vol-down" class="remote-btn w-10 h-10">
                    <i class="fas fa-minus"></i>
                </button>
                <button id="remote-vol-up" class="remote-btn w-10 h-10">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>
    </div>

    <button id="show-remote-btn"
        class="absolute top-4 right-4 z-40 text-white bg-black/50 p-2 rounded hover:bg-green-600 transition">
        <i class="fas fa-chevron-left"></i>
    </button>

    <!-- Show Menu Button (Fixed) -->
    <button id="show-menu-btn"
        class="absolute top-4 left-4 z-40 text-white bg-black/50 p-2 rounded hover:bg-green-600 transition hidden">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Main Viewport -->
    <div class="flex-1 flex items-center justify-center bg-black relative w-full h-full overflow-hidden">

        <!-- The Container that respects aspect ratio -->
        <div id="aspect-container" class="relative bg-black shadow-2xl overflow-hidden"
            style="width: 100%; height: 100%; max-width: 177.78vh; max-height: 56.25vw;">

            <!-- Selection Box Overlay -->
            <div id="selection-box"></div>

            <!-- Layer 1: The TV Content -->
            <!-- We change classes here to move it between back (chroma) and front (manual) -->
            <div id="tv-layer-container" class="absolute inset-0 pointer-events-none overflow-hidden z-10">
                <div id="tv-transform-wrapper"
                    class="relative w-full h-full flex items-center justify-center transform transition-transform duration-75">
                    <!-- Static Noise Canvas (Fallback) -->
                    <canvas id="static-canvas" class="absolute inset-0 w-full h-full z-0 opacity-100"></canvas>

                    <!-- The User's TV Video (File) -->
                    <video id="tv-video" loop playsinline crossorigin="anonymous"
                        class="absolute max-w-none z-10 hidden"
                        style="width: 100%; height: 100%; object-fit: cover;"></video>

                    <!-- YouTube Player Wrapper -->
                    <div id="yt-player-container" class="absolute inset-0 w-full h-full z-10 hidden">
                        <div id="yt-player" class="w-full h-full"></div>
                    </div>

                    <div id="emulator-container" class="absolute inset-0 w-full h-full z-10 hidden"
                        style="pointer-events: auto;">
                        <div id="game" class="w-full h-full" style="pointer-events: auto;"></div>
                    </div>

                    <!-- Retro Browser Container -->
                    <div id="browser-container"
                        class="absolute inset-0 w-full h-full z-10 hidden flex flex-col bg-gray-200"
                        style="pointer-events: auto;">
                        <div class="browser-toolbar">
                            <button class="browser-btn"
                                onclick="document.getElementById('browser-frame').contentWindow.history.back()"><i
                                    class="fas fa-arrow-left"></i></button>
                            <button class="browser-btn"
                                onclick="document.getElementById('browser-frame').contentWindow.history.forward()"><i
                                    class="fas fa-arrow-right"></i></button>
                            <button class="browser-btn"
                                onclick="document.getElementById('browser-frame').src = document.getElementById('web-url').value"><i
                                    class="fas fa-redo"></i></button>
                            <div class="browser-address" id="browser-address-bar">http://...</div>
                        </div>
                        <div class="flex-1 overflow-hidden relative w-full h-full">
                            <iframe id="browser-frame" src="about:blank"
                                sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
                        </div>
                    </div>

                    <!-- Dial-up Overlay -->
                    <div id="dialup-overlay"
                        class="absolute inset-0 z-50 flex items-center justify-center hidden pointer-events-none">
                        <div class="dialup-overlay w-3/4 max-w-sm p-1 pointer-events-auto">
                            <div class="dialup-header">
                                <span>Sign On</span>
                                <span
                                    class="bg-gray-300 text-black px-1 text-xs font-bold shadow-sm cursor-pointer">X</span>
                            </div>
                            <div class="bg-gray-200 p-4 flex flex-col items-center">
                                <div class="flex gap-4 mb-4">
                                    <div
                                        class="w-16 h-16 bg-white border border-gray-500 flex items-center justify-center">
                                        <i class="fas fa-laptop-house text-2xl text-gray-600"></i>
                                    </div>
                                    <div class="w-16 h-16 border border-gray-500 flex items-center justify-center"><i
                                            class="fas fa-exchange-alt text-xl text-gray-400"></i></div>
                                    <div
                                        class="w-16 h-16 bg-white border border-gray-500 flex items-center justify-center">
                                        <i class="fas fa-globe text-2xl text-blue-600 animate-pulse"></i>
                                    </div>
                                </div>
                                <div id="dialup-status" class="text-sm font-bold text-black mb-2">Dialing...</div>
                                <div class="w-full bg-white h-4 border border-gray-600 p-0.5">
                                    <div id="dialup-bar" class="h-full bg-blue-800 w-0 transition-all duration-300">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TV CRT Overlay -->
                    <div id="crt-overlay-tv"
                        class="absolute inset-0 z-20 crt-overlay opacity-0 pointer-events-none hidden"></div>
                </div>
            </div>

            <!-- Layer 2: The Room (Canvas) -->
            <canvas id="room-canvas"
                class="absolute inset-0 w-full h-full z-20 pointer-events-none object-cover"></canvas>

            <!-- Hidden source video for the room -->
            <video id="room-video" loop muted playsinline crossorigin="anonymous" class="hidden"></video>
            <img id="room-image" class="hidden" crossorigin="anonymous">

            <!-- CRT Scanline Overlay (Screen) -->
            <div id="crt-overlay-screen" class="absolute inset-0 z-30 crt-overlay opacity-30 pointer-events-none"></div>

            <!-- Instructions Overlay (Removed once started) -->
            <div id="start-overlay"
                class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/80 text-center p-8">
                <h1 class="text-6xl text-green-500 mb-4 animate-pulse" style="text-shadow: 0 0 20px green;">NO SIGNAL
                </h1>
                <p class="text-xl text-gray-300 mb-8 max-w-md">Upload a room video to start. Use the mixer to add custom
                    audio.</p>
                <button onclick="document.getElementById('room-upload').click()"
                    class="px-6 py-3 bg-green-700 hover:bg-green-600 text-white font-bold rounded shadow-[0_0_15px_rgba(0,255,0,0.5)]">
                    UPLOAD ROOM SOURCE
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        const state = {
            isPlaying: false,
            audioContext: null,
            method: 'chroma', // 'chroma' or 'manual'
            tvSource: 'file', // 'file', 'youtube', or 'game'
            ytPlayer: null,
            emulator: null, // EmulatorJS instance
            gameFile: null, // Current ROM file
            gameSystem: '', // Selected system (nes, segaMD)
            chroma: {
                threshold: 90,
                softness: 20
            },
            tvTransform: {
                scale: 1,
                rotate: 0,
                x: 0,
                y: 0
            },
            manualSelection: {
                active: false,
                x: 0, y: 0, w: 0, h: 0
            },
            audio: {
                birds: { active: false, vol: 0.5, freq: 0.5, int: 0.5, buffer: null, customNode: null },
                car: { active: false, vol: 0.5, freq: 0.5, buffer: null, customNode: null },
                mower: { active: false, vol: 0.5, dist: 0.5, instance: null, buffer: null, customNode: null },
                house: { active: false, vol: 0.5, instance: null, buffer: null, customNode: null }
            },
            roomVideoPath: null, // Track path for saving
            roomMediaType: 'video', // 'video' or 'image'
            ytState: { url: '', index: 0, time: 0 }, // For resuming
            effects: {
                crt: { enabled: true, intensity: 0.3, scope: 'screen' },
                tv: { brightness: 1, contrast: 1, saturation: 1, hue: 0, blur: 0, sepia: 0 }
            },
            lockedManual: false,
            ads: {
                // Config
                config: null,
                enabled: true, // Master toggle
                adsPerBreak: 2, // How many ads to play

                // Runtime State
                isPlayingAd: false,
                playCountInBreak: 0,

                // Resume State (for returning to main content)
                resumeState: {
                    type: null, // 'playlist' or 'video'
                    url: null,
                    listId: null,
                    videoId: null,
                    index: 0,
                    time: 0
                },

                // Persistent Tracking (videoId -> count)
                videoPlayCounts: {},

                // Runtime queue of ad videos to play
                adQueue: []
            }
        };

        let currentRoomFile = null; // Stored for upload logic

        // --- DOM Elements ---
        const roomVideo = document.getElementById('room-video');
        const roomImage = document.getElementById('room-image');
        const roomCanvas = document.getElementById('room-canvas');
        const tvVideo = document.getElementById('tv-video');
        const staticCanvas = document.getElementById('static-canvas');
        const ctx = roomCanvas.getContext('2d', { willReadFrequently: true });
        const staticCtx = staticCanvas.getContext('2d');
        const tvWrapper = document.getElementById('tv-transform-wrapper');
        const tvLayerContainer = document.getElementById('tv-layer-container');
        const aspectContainer = document.getElementById('aspect-container');
        const selectionBox = document.getElementById('selection-box');
        const ytContainer = document.getElementById('yt-player-container');
        const emulatorContainer = document.getElementById('emulator-container');
        const seekSlider = document.getElementById('video-seek');
        const timeDisplay = document.getElementById('video-time');

        // --- Layout & resizing ---
        function setRatio(ratio) {
            if (ratio === '16:9') {
                aspectContainer.style.maxWidth = '177.78vh';
                aspectContainer.style.maxHeight = '56.25vw';
                aspectContainer.style.aspectRatio = '16/9';
            } else {
                aspectContainer.style.maxWidth = '56.25vh';
                aspectContainer.style.maxHeight = '177.78vw';
                aspectContainer.style.aspectRatio = '9/16';
            }
            resizeCanvases();
        }



        // Set default high-res canvas (prevents low-res static on startup)
        roomCanvas.width = 1920;
        roomCanvas.height = 1080;
        staticCanvas.width = 1920;
        staticCanvas.height = 1080;

        function resizeCanvases() {
            // Only defaults if no media is present or logic dictates
            // For now, we allow the canvas to retain the resolution of the loaded media
            // If explicit resize is needed, we do it elsewhere
        }

        // Removed window.resize listener to prevent downscaling resolution
        // window.addEventListener('resize', resizeCanvases);

        // --- Sidebar Logic ---
        const sidebar = document.getElementById('sidebar');
        const hideBtn = document.getElementById('hide-menu-btn');
        const showBtn = document.getElementById('show-menu-btn');

        hideBtn.addEventListener('click', () => {
            sidebar.classList.add('hidden-panel');
            showBtn.classList.remove('hidden');
        });

        showBtn.addEventListener('click', () => {
            sidebar.classList.remove('hidden-panel');
            showBtn.classList.add('hidden');
        });

        // --- Remote Logic ---
        const remotePanel = document.getElementById('remote-panel');

        const hideRemoteBtn = document.getElementById('hide-remote-btn');
        const showRemoteBtn = document.getElementById('show-remote-btn');

        // Remote Toggle
        hideRemoteBtn.addEventListener('click', () => {
            remotePanel.classList.remove('visible-panel');
            // Note: CSS default transform is 100% (hidden). Class visible-panel makes it 0.
            showRemoteBtn.classList.remove('hidden');
        });
        showRemoteBtn.addEventListener('click', () => {
            remotePanel.classList.add('visible-panel');
            showRemoteBtn.classList.add('hidden');
        });

        // Remote Controls
        let isTvPowerOn = true;
        const remotePowerBtn = document.getElementById('remote-power');

        remotePowerBtn.addEventListener('click', () => {
            isTvPowerOn = !isTvPowerOn;
            remotePowerBtn.classList.toggle('on');
            const tvContainer = document.getElementById('tv-layer-container');

            if (isTvPowerOn) {
                tvContainer.style.visibility = 'visible';
                if (state.tvSource === 'file' && tvVideo.src) tvVideo.play();
            } else {
                tvContainer.style.visibility = 'hidden';
                if (state.tvSource === 'file') tvVideo.pause();
                if (state.ytPlayer && state.ytPlayer.pauseVideo) state.ytPlayer.pauseVideo();
            }
        });

        document.getElementById('remote-play').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            if (state.tvSource === 'file' && tvVideo.src) tvVideo.play();
            if (state.tvSource === 'youtube' && state.ytPlayer?.playVideo) state.ytPlayer.playVideo();
        });

        document.getElementById('remote-pause').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            if (state.tvSource === 'file' && tvVideo.src) tvVideo.pause();
            if (state.tvSource === 'youtube' && state.ytPlayer?.pauseVideo) state.ytPlayer.pauseVideo();
        });

        document.getElementById('remote-eject').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            unloadTV();
        });

        document.getElementById('remote-vol-up').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            let c = parseFloat(document.getElementById('vol-tv').value);
            c = Math.min(1, c + 0.05);
            updateVolume('tv', c, 'remote');
        });

        document.getElementById('remote-vol-down').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            let c = parseFloat(document.getElementById('vol-tv').value);
            c = Math.max(0, c - 0.05);
            updateVolume('tv', c, 'remote');
        });

        document.getElementById('remote-next').addEventListener('click', () => {
            if (!isTvPowerOn) return;

            if (state.tvSource === 'youtube') {
                // 1. If Ad is playing, skip it (user wants to skip ad)
                if (state.ads && state.ads.isPlayingAd) {
                    console.log("Skipping Ad via Remote");
                    handleAdFinished();
                    return;
                }

                // 2. If valid normal content, try to trigger ad break
                if (state.ads && state.ads.enabled && state.ads.adsPerBreak > 0 && state.ads.config) {
                    const activeLists = state.ads.config.lists.filter(l => l.enabled);
                    const player = state.ytPlayer;
                    // Only trigger if in a playlist
                    const listId = player && typeof player.getPlaylistId === 'function' ? player.getPlaylistId() : null;

                    if (activeLists.length > 0 && listId) {
                        console.log("Triggering Ad Break via Remote Next");
                        const idx = player.getPlaylistIndex();
                        state.ads.resumeState = {
                            type: 'playlist',
                            listId: listId,
                            index: idx + 1,
                            time: 0
                        };
                        startAdBreak();
                        return;
                    }
                }

                // 3. Fallback to normal behavior
                if (state.ytPlayer?.nextVideo) state.ytPlayer.nextVideo();
            }
        });

        document.getElementById('remote-prev').addEventListener('click', () => {
            if (!isTvPowerOn) return;
            if (state.tvSource === 'youtube' && state.ytPlayer?.previousVideo) state.ytPlayer.previousVideo();
        });

        // --- Source Selection Logic ---
        const sourceRadios = document.getElementsByName('tv-source');
        const fileContainer = document.getElementById('source-file-container');
        const ytInputContainer = document.getElementById('source-youtube-container');

        sourceRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.tvSource = e.target.value;
                if (state.tvSource === 'youtube') {
                    fileContainer.classList.add('hidden');
                    ytInputContainer.classList.remove('hidden');
                    // Clean up file video
                    tvVideo.classList.add('hidden');
                    if (!tvVideo.paused) tvVideo.pause();
                } else {
                    fileContainer.classList.remove('hidden');
                    ytInputContainer.classList.add('hidden');
                    // Clean up YouTube
                    ytContainer.classList.add('hidden');
                    if (state.ytPlayer && state.ytPlayer.pauseVideo) state.ytPlayer.pauseVideo();
                    if (tvVideo.src) tvVideo.classList.remove('hidden');
                }
            });
        });

        // --- Watch Party Logic ---
        let socket = null;
        let peer = null;
        let partyRoomId = null;
        let isPartyHost = false;
        let partyPeers = {}; // { socketId: call }

        const initSocket = () => {
            if (socket) return;
            socket = io();

            socket.on('connect', () => {
                console.log('Socket Connected:', socket.id);
            });

            socket.on('user-joined', (userId) => {
                console.log('User joined party:', userId);
                // Host initiates peer call if streaming local video
                if (isPartyHost && state.tvSource === 'file') {
                    callPeer(userId);
                }
            });

            socket.on('sync-state', (remoteState) => {
                console.log('Received State Sync', remoteState);
                applyRemoteState(remoteState);
            });

            socket.on('peer-id', (data) => {
                console.log("Got Peer ID:", data);
                peerMap[data.from] = data.peerId;
                if (isPartyHost) callPeer(data.from);
            });
        };

        const generateCode = () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        };

        document.getElementById('btn-host-party').addEventListener('click', () => {
            initSocket();
            partyRoomId = generateCode();
            isPartyHost = true;

            socket.emit('join-room', partyRoomId, true);

            document.getElementById('host-code-display').innerText = partyRoomId;
            document.getElementById('host-code-display').classList.remove('hidden');
            document.getElementById('host-status').innerText = "Hosting... Waiting for viewers.";

            // Init PeerJS for Host
            initPeer(true);

            // Start Sync Loop
            setInterval(syncHostState, 1000);
        });

        document.getElementById('btn-join-party').addEventListener('click', () => {
            const code = document.getElementById('join-code-input').value.toUpperCase();
            if (code.length !== 6) {
                alert("Invalid Code");
                return;
            }
            initSocket();
            partyRoomId = code;
            isPartyHost = false;

            socket.emit('join-room', partyRoomId, false);
            document.getElementById('join-status').innerText = "Joined Party: " + code;

            // Init PeerJS for Viewer
            initPeer(false);
        });

        const initPeer = (isHost) => {
            peer = new Peer(undefined, {
                debug: 2
            });

            peer.on('open', (id) => {
                console.log('My Peer ID:', id);
                // Send peer ID to room via socket?
                // Actually relying on socket.io signaling mostly, but PeerJS needs IDs.
                // We can map SocketID <-> PeerID if needed, or just broadcast PeerID to room
                if (socket) socket.emit('peer-id', { roomId: partyRoomId, peerId: id });
            });

            peer.on('call', (call) => {
                // Viewer receiving call from Host
                call.answer(); // Answer without stream? Or with placeholder?
                call.on('stream', (remoteStream) => {
                    console.log('Received Video Stream');
                    // Set TV source to this stream
                    state.tvSource = 'stream';
                    tvVideo.srcObject = remoteStream;
                    tvVideo.play();
                    // override UI
                    tvVideo.classList.remove('hidden');
                    ytContainer.classList.add('hidden');
                });
            });
        };

        const callPeer = (socketId) => {
            const peerId = peerMap[socketId];
            if (partyPeers[socketId] && partyPeers[socketId].open) return;

            if (peerId && peer) {
                console.log("Calling Peer:", peerId);
                if (state.tvSource === 'file') {
                    try {
                        const stream = tvVideo.captureStream ? tvVideo.captureStream() : (tvVideo.mozCaptureStream ? tvVideo.mozCaptureStream() : null);
                        if (stream) {
                            const call = peer.call(peerId, stream);
                            partyPeers[socketId] = call;
                            call.on('close', () => delete partyPeers[socketId]);
                            call.on('error', () => delete partyPeers[socketId]);
                        }
                    } catch (e) {
                        console.error("Stream capture failed", e);
                    }
                }
            }
        };

        // Listen for Peer IDs
        const peerMap = {}; // socketId -> peerId

        // Add to initSocket:
        // socket.on('peer-id', (data) => {
        //     peerMap[data.from] = data.peerId;
        //     if(isPartyHost && state.tvSource === 'file') {
        //          // If we have a stream, call them
        //          const stream = tvVideo.captureStream();
        //          const call = peer.call(data.peerId, stream);
        //     }
        // });

        const syncHostState = () => {
            if (!isPartyHost || !socket) return;

            // Gather State
            const syncData = {
                tvSource: state.tvSource,
                file: (state.tvSource === 'url') ? document.getElementById('yt-url').value : null,
                // For YouTube, need ID and Time
                ytId: (state.ytPlayer && state.ytPlayer.getVideoData) ? state.ytPlayer.getVideoData().video_id : null,
                ytTime: (state.ytPlayer && state.ytPlayer.getCurrentTime) ? state.ytPlayer.getCurrentTime() : 0,
                ytState: (state.ytPlayer && state.ytPlayer.getPlayerState) ? state.ytPlayer.getPlayerState() : -1,

                // Configs
                background: document.getElementById('bg-video').src,
                ads: state.ads,
                audio: state.audio,
                // etc...
            };

            socket.emit('sync-state', { roomId: partyRoomId, state: syncData });
        };

        const applyRemoteState = (remote) => {
            if (isPartyHost) return; // Host ignores

            // Apply Background
            const bgVideo = document.getElementById('bg-video');
            if (remote.background && !bgVideo.src.includes(remote.background)) { // crude check
                // only if remote is a full URL or path we can resolve. 
                // If it's a blob url (local file), we can't sync it easily without stream.
                // Assuming server path for backgrounds.
                if (remote.background.startsWith('http') || remote.background.startsWith('blob') === false) {
                    bgVideo.src = remote.background;
                }
            }

            // Apply TV Source
            if (remote.tvSource === 'youtube') {
                if (state.tvSource !== 'youtube' || !state.ytPlayer) {
                    loadYoutubeVideo(remote.ytId);
                } else {
                    // Sync Time & State
                    const diff = Math.abs(state.ytPlayer.getCurrentTime() - remote.ytTime);
                    if (diff > 2) state.ytPlayer.seekTo(remote.ytTime);

                    if (remote.ytState === 1 && state.ytPlayer.getPlayerState() !== 1) state.ytPlayer.playVideo();
                    if (remote.ytState === 2 && state.ytPlayer.getPlayerState() !== 2) state.ytPlayer.pauseVideo();
                }
            }
            // For 'file', we rely on PeerJS stream established elsewhere.
        };

        const formatTime = (seconds) => {
            if (!seconds || isNaN(seconds) || seconds < 0) return "00:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        };

        const updateSeekBar = () => {
            if (isSeeking) return; // Don't update while dragging

            let currentTime = 0;
            let duration = 0;

            if (state.tvSource === 'file' && tvVideo) {
                currentTime = tvVideo.currentTime || 0;
                duration = tvVideo.duration || 0;
            } else if (state.tvSource === 'youtube' && state.ytPlayer && state.ytPlayer.getCurrentTime) {
                currentTime = state.ytPlayer.getCurrentTime() || 0;
                duration = state.ytPlayer.getDuration() || 0;
            }

            if (duration > 0) {
                seekSlider.value = (currentTime / duration) * 100;
                timeDisplay.innerText = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            } else {
                seekSlider.value = 0;
                timeDisplay.innerText = "00:00 / 00:00";
            }
        };

        // Update loop for smooth seek bar (runs independently of game loop)
        setInterval(updateSeekBar, 500);

        // Slider Interaction
        seekSlider.addEventListener('mousedown', () => isSeeking = true);
        seekSlider.addEventListener('touchstart', () => isSeeking = true);

        const handleSeek = (e) => {
            const percent = parseFloat(e.target.value);
            let duration = 0;

            if (state.tvSource === 'file' && tvVideo) {
                duration = tvVideo.duration || 0;
                if (duration > 0) tvVideo.currentTime = (percent / 100) * duration;
            } else if (state.tvSource === 'youtube' && state.ytPlayer && state.ytPlayer.seekTo) {
                duration = state.ytPlayer.getDuration() || 0;
                if (duration > 0) state.ytPlayer.seekTo((percent / 100) * duration, true);
            }

            // Optimistic update of text while dragging
            if (duration > 0) {
                const seekTime = (percent / 100) * duration;
                timeDisplay.innerText = `${formatTime(seekTime)} / ${formatTime(duration)}`;
            }
        };

        seekSlider.addEventListener('input', handleSeek); // Real-time scrubbing
        seekSlider.addEventListener('change', (e) => { // Commit
            isSeeking = false;
            handleSeek(e);
        });
        seekSlider.addEventListener('mouseup', () => isSeeking = false);
        seekSlider.addEventListener('touchend', () => isSeeking = false);


        // --- Placement Method Logic ---
        const methodRadios = document.getElementsByName('place-method');
        const chromaControls = document.getElementById('chroma-controls');
        const transformControls = document.getElementById('transform-controls');
        const manualHint = document.getElementById('manual-hint');

        const updateMethodUI = () => {
            if (state.method === 'manual') {
                chromaControls.classList.add('opacity-30', 'pointer-events-none');
                manualHint.classList.remove('hidden');

                document.getElementById('tv-scale').disabled = true;
                document.getElementById('tv-rotate').disabled = true;
                document.getElementById('tv-x').disabled = true;
                document.getElementById('tv-y').disabled = true;
                transformControls.classList.add('opacity-50');

                tvLayerContainer.classList.remove('tv-layer-back');
                tvLayerContainer.classList.add('tv-layer-front');
                aspectContainer.classList.add('cursor-crosshair');

                if (state.manualSelection.w === 0) {
                    tvLayerContainer.style.width = '0px';
                    tvLayerContainer.style.height = '0px';
                } else {
                    applyManualLayout();
                }
            } else {
                chromaControls.classList.remove('opacity-30', 'pointer-events-none');
                manualHint.classList.add('hidden');

                document.getElementById('tv-scale').disabled = false;
                document.getElementById('tv-rotate').disabled = false;
                document.getElementById('tv-x').disabled = false;
                document.getElementById('tv-y').disabled = false;
                transformControls.classList.remove('opacity-50');

                tvLayerContainer.classList.remove('tv-layer-front');
                tvLayerContainer.classList.add('tv-layer-back');
                aspectContainer.classList.remove('cursor-crosshair');
                selectionBox.style.display = 'none';

                tvLayerContainer.style.left = '0';
                tvLayerContainer.style.top = '0';
                tvLayerContainer.style.width = '100%';
                tvLayerContainer.style.height = '100%';
                updateTVTransform();
            }
        };

        methodRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.method = e.target.value;
                updateMethodUI();
            });
        });

        // --- Fit Mode Logic ---
        const fitSelect = document.getElementById('video-fit');
        fitSelect.addEventListener('change', (e) => {
            const fit = e.target.value; // cover, contain, fill

            // Apply to File Video
            tvVideo.style.objectFit = fit;

            // Apply to YouTube Iframe (simulated via width/height CSS if possible, but iframe content is internal)
            // Best approach for iframe is changing the dimensions of the inner div
            const ytFrame = document.querySelector('#yt-player iframe');
            if (ytFrame) {
                if (fit === 'contain') {
                    // Not perfectly supported natively by YT iframe without black bars logic, 
                    // but we can ensure the container doesn't crop
                    ytFrame.style.width = '100%';
                    ytFrame.style.height = '100%';
                    ytFrame.style.objectFit = 'contain';
                } else if (fit === 'cover') {
                    ytFrame.style.width = '100%';
                    ytFrame.style.height = '100%';
                }
            }
        });

        // --- Manual Selection Interaction ---
        let isSelecting = false;
        let startX = 0;
        let startY = 0;

        document.getElementById('lock-manual').addEventListener('change', (e) => {
            state.lockedManual = e.target.checked;
            if (state.lockedManual) {
                aspectContainer.classList.remove('cursor-crosshair');
                document.getElementById('manual-hint').classList.add('hidden');
            } else if (state.method === 'manual') {
                aspectContainer.classList.add('cursor-crosshair');
                document.getElementById('manual-hint').classList.remove('hidden');
            }
        });

        aspectContainer.addEventListener('mousedown', (e) => {
            if (state.method !== 'manual' || state.lockedManual) return;
            isSelecting = true;

            const rect = aspectContainer.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            tvLayerContainer.style.width = '0px';
            tvLayerContainer.style.height = '0px';
        });

        // --- Tab Switching Logic ---
        // --- Tab Switching Logic ---
        const tabs = ['file', 'url', 'channels', 'games', 'web', 'party'];
        tabs.forEach(t => {
            document.getElementById(`tab-${t}`).addEventListener('click', () => {
                // Update visual tabs
                tabs.forEach(other => {
                    const btn = document.getElementById(`tab-${other}`);
                    const panel = document.getElementById(`panel-${other}`);
                    if (other === t) {
                        btn.classList.add('active-tab', 'text-white', 'bg-gray-700');
                        btn.classList.remove('text-gray-400', 'bg-gray-800');
                        panel.classList.remove('hidden');
                        panel.classList.add('block');
                    } else {
                        btn.classList.remove('active-tab', 'text-white', 'bg-gray-700');
                        btn.classList.add('text-gray-400', 'bg-gray-800');
                        panel.classList.remove('block');
                        panel.classList.add('hidden');
                    }
                });

                // Set state logic
                if (t === 'file') {
                    state.tvSource = 'file';
                    tvVideo.classList.remove('hidden');
                    ytContainer.classList.add('hidden');
                    emulatorContainer.classList.add('hidden');
                    browserContainer.classList.add('hidden');
                    if (tvVideo.src) {
                        tvVideo.play().catch(() => { });
                    }
                    if (state.ytPlayer && state.ytPlayer.pauseVideo) state.ytPlayer.pauseVideo();
                    if (state.emulator) {
                        // Pause emulator if possible
                        try {
                            if (state.emulator.pause) state.emulator.pause();
                        } catch (e) { }
                    }
                } else if (t === 'games') {
                    state.tvSource = 'game';
                    tvVideo.classList.add('hidden');
                    ytContainer.classList.add('hidden');
                    emulatorContainer.classList.remove('hidden');
                    browserContainer.classList.add('hidden');
                    if (tvVideo.paused === false) tvVideo.pause();
                    if (state.ytPlayer && state.ytPlayer.pauseVideo) state.ytPlayer.pauseVideo();
                } else if (t === 'web') {
                    state.tvSource = 'web';
                    tvVideo.classList.add('hidden');
                    ytContainer.classList.add('hidden');
                    emulatorContainer.classList.add('hidden');
                    browserContainer.classList.remove('hidden');
                    if (tvVideo.paused === false) tvVideo.pause();
                    if (state.ytPlayer && state.ytPlayer.pauseVideo) state.ytPlayer.pauseVideo();
                    if (state.emulator) {
                        try { if (state.emulator.pause) state.emulator.pause(); } catch (e) { }
                    }
                } else if (t === 'party') {
                    // Do nothing to source, allowing overlay interaction
                } else {
                    // Both URL and Channels use YouTube source type
                    state.tvSource = 'youtube';
                    tvVideo.classList.add('hidden');
                    ytContainer.classList.add('hidden');
                    browserContainer.classList.add('hidden');
                    ytContainer.classList.remove('hidden');
                    emulatorContainer.classList.add('hidden');
                    if (tvVideo.paused === false) tvVideo.pause();
                    if (state.emulator) {
                        try {
                            if (state.emulator.pause) state.emulator.pause();
                        } catch (e) { }
                    }
                }
            });
        });

        // --- WEB / DIALUP LOGIC ---
        const browserContainer = document.getElementById('browser-container');
        const dialupOverlay = document.getElementById('dialup-overlay');
        const dialupStatus = document.getElementById('dialup-status');
        const dialupBar = document.getElementById('dialup-bar');
        const btnDialup = document.getElementById('btn-dialup');
        const browserFrame = document.getElementById('browser-frame');
        const browserAddress = document.getElementById('browser-address-bar');

        btnDialup.addEventListener('click', () => {
            const url = document.getElementById('web-url').value;
            startWebSession(url);
        });

        function startWebSession(url) {
            // 1. Reset UI
            browserContainer.classList.remove('hidden');
            browserFrame.classList.add('hidden'); // Hide frame until loaded
            dialupOverlay.classList.remove('hidden');
            dialupStatus.innerText = "Initializing Modem...";
            dialupBar.style.width = '0%';

            // 2. Play Sound
            const audio = new Audio('sounds/dialup.mp3');
            audio.volume = 0.5;

            // Events
            setTimeout(() => { dialupStatus.innerText = "Dialing 555-0199..."; dialupBar.style.width = '10%'; }, 1000);
            setTimeout(() => { dialupStatus.innerText = "Handshaking..."; dialupBar.style.width = '40%'; }, 4000);
            setTimeout(() => { dialupStatus.innerText = "Verifying Username..."; dialupBar.style.width = '60%'; }, 12000);
            setTimeout(() => { dialupStatus.innerText = "Connected!"; dialupBar.style.width = '100%'; }, 26000); // end of clip approx

            audio.play().catch(e => console.error("Audio play failed", e));

            audio.onended = () => {
                // Done
                dialupOverlay.classList.add('hidden');
                browserFrame.classList.remove('hidden');
                browserFrame.src = url;
                browserAddress.innerText = url;
            };

            // Fallback if audio fails or is too long/short
            // audio.duration might be NaN initially, used onended as primary
        }

        // --- Channels Logic ---
        function fetchChannels() {
            fetch('/api/channels')
                .then(res => res.json())
                .then(channels => {
                    channels.sort((a, b) => (a.channel || 999) - (b.channel || 999));
                    const list = document.getElementById('channels-list');
                    list.innerHTML = '';
                    if (channels.length > 0) {
                        list.classList.remove('hidden');
                        channels.forEach(ch => {
                            const div = document.createElement('div');
                            div.className = 'bg-gray-800 p-2 cursor-pointer hover:bg-gray-700 border border-gray-700 rounded flex flex-col gap-1';

                            if (ch.img) {
                                const img = document.createElement('img');
                                img.src = ch.img;
                                img.className = 'w-full h-24 object-cover rounded bg-black mb-1';
                                div.appendChild(img);
                            }

                            const text = document.createElement('div');
                            text.className = 'w-full flex justify-between items-center';
                            const title = document.createElement('span');
                            title.className = 'text-xs text-green-400 font-bold truncate tracking-wide';
                            title.innerText = (ch.channel ? `CH ${ch.channel} ` : '') + (ch.title || "Unknown");
                            const desc = document.createElement('span');
                            desc.className = 'text-[10px] text-gray-500 whitespace-nowrap ml-2';
                            desc.innerText = ch.year || "";
                            text.appendChild(title);
                            text.appendChild(desc);

                            div.appendChild(text);

                            div.addEventListener('click', () => {
                                document.getElementById('yt-url').value = ch.url;
                                loadYoutube(ch.url);
                                // Set active state logic if needed
                            });

                            list.appendChild(div);
                        });
                    }
                })
                .catch(err => console.log("Channels API not available or empty"));
        }

        // Init Channels
        fetchChannels();

        // --- Games/Emulator Logic ---
        const gameSystemSelect = document.getElementById('game-system');
        const romUploadInput = document.getElementById('rom-upload');
        const romFilenameDisplay = document.getElementById('rom-filename');
        const gameLoadBtn = document.getElementById('game-load-btn');

        // Handle system selection
        gameSystemSelect.addEventListener('change', (e) => {
            state.gameSystem = e.target.value;
            updateGameLoadButton();
        });

        // Handle ROM file upload
        romUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                state.gameFile = file;
                romFilenameDisplay.textContent = file.name;
                romFilenameDisplay.classList.remove('text-gray-500');
                romFilenameDisplay.classList.add('text-green-400');
                updateGameLoadButton();
            } else {
                state.gameFile = null;
                romFilenameDisplay.textContent = "No ROM loaded";
                romFilenameDisplay.classList.remove('text-green-400');
                romFilenameDisplay.classList.add('text-gray-500');
                updateGameLoadButton();
            }
        });

        function updateGameLoadButton() {
            if (state.gameSystem && state.gameFile) {
                gameLoadBtn.disabled = false;
            } else {
                gameLoadBtn.disabled = true;
            }
        }

        // Load game into emulator
        gameLoadBtn.addEventListener('click', () => {
            if (!state.gameSystem || !state.gameFile) {
                console.error('Need both system and ROM file to load game');
                return;
            }

            loadGame(state.gameSystem, state.gameFile);
        });

        function loadGame(system, romFile) {
            // Clear any existing emulator
            if (state.emulator && state.emulator.loaded) {
                try {
                    const gameDiv = document.getElementById('game');
                    gameDiv.innerHTML = '';
                } catch (e) {
                    console.error('Error clearing emulator:', e);
                }
            }

            // Create a URL for the ROM file
            const romUrl = URL.createObjectURL(romFile);

            console.log('Loading game:', { system, fileName: romFile.name, romUrl });

            // Clear the game container
            const gameDiv = document.getElementById('game');
            gameDiv.innerHTML = '';

            // Show the emulator container and hide static
            emulatorContainer.classList.remove('hidden');
            staticCanvas.style.opacity = '0';

            // Set global variables for EmulatorJS BEFORE loading the script
            window.EJS_player = '#game';
            window.EJS_core = system;
            window.EJS_gameUrl = romUrl;
            window.EJS_pathtodata = 'https://cdn.emulatorjs.org/stable/data/';
            window.EJS_startOnLoaded = true; // Auto-start when loaded
            window.EJS_volume = 1.0; // Set volume to 100%
            window.EJS_gameName = romFile.name; // Set game name

            console.log('EmulatorJS config set:', {
                player: window.EJS_player,
                core: window.EJS_core,
                gameUrl: window.EJS_gameUrl
            });

            // Remove any existing loader script
            const oldScript = document.querySelector('script[src*="emulatorjs"][src*="loader"]');
            if (oldScript) {
                console.log('Removing old EmulatorJS script');
                oldScript.remove();
            }

            // Load the EmulatorJS loader script
            const script = document.createElement('script');
            script.src = 'https://cdn.emulatorjs.org/stable/data/loader.js';

            script.onload = () => {
                console.log('EmulatorJS loader script loaded successfully');
                state.emulator = {
                    system,
                    romFile,
                    romUrl,
                    loaded: true
                };
            };

            script.onerror = (error) => {
                console.error('Failed to load EmulatorJS script:', error);
                alert('Failed to load the emulator. Please check your internet connection and try again.');
                // Show static again on error
                staticCanvas.style.opacity = '1';
                emulatorContainer.classList.add('hidden');
            };

            document.head.appendChild(script);

            // Watch for when emulator content is added and auto-focus/click it
            setTimeout(() => {
                const gameCanvas = document.querySelector('#game canvas');
                if (gameCanvas) {
                    gameCanvas.setAttribute('tabindex', '0');
                    gameCanvas.focus();
                    gameCanvas.click();
                    console.log('Auto-focused and clicked emulator for input/audio');
                }
            }, 3000);
        }

        window.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;

            const rect = aspectContainer.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX);
            const top = Math.min(currentY, startY);

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        });

        window.addEventListener('mouseup', (e) => {
            if (!isSelecting) return;
            isSelecting = false;

            const rect = aspectContainer.getBoundingClientRect();
            const sbRect = selectionBox.getBoundingClientRect();

            if (sbRect.width > 10 && sbRect.height > 10) {
                const relativeLeft = sbRect.left - rect.left;
                const relativeTop = sbRect.top - rect.top;

                state.manualSelection = {
                    x: (relativeLeft / rect.width) * 100,
                    y: (relativeTop / rect.height) * 100,
                    w: (sbRect.width / rect.width) * 100,
                    h: (sbRect.height / rect.height) * 100
                };
                applyManualLayout();
            }

            selectionBox.style.display = 'none';
        });

        function applyManualLayout() {
            if (state.method !== 'manual') return;
            const sel = state.manualSelection;

            tvLayerContainer.style.left = sel.x + '%';
            tvLayerContainer.style.top = sel.y + '%';
            tvLayerContainer.style.width = sel.w + '%';
            tvLayerContainer.style.height = sel.h + '%';
            tvWrapper.style.transform = 'translate(0, 0) scale(1) rotate(0deg)';
        }

        // --- YouTube API Integration ---
        function onYouTubeIframeAPIReady() {
            // Placeholder, player created on demand
        }

        function loadYoutube(url, startSeconds = 0, startListIndex = 0) {
            // Reset Ad State on any manual load so we don't carry over ad modes/loops
            if (typeof cancelAdBreak === 'function') cancelAdBreak();

            let videoId = null;
            let listId = null;
            try {
                const urlObj = new URL(url);
                if (urlObj.searchParams.has('list')) listId = urlObj.searchParams.get('list');
                if (urlObj.searchParams.has('v')) videoId = urlObj.searchParams.get('v');
                if (url.includes('youtu.be/')) videoId = url.split('youtu.be/')[1].split('?')[0];
            } catch (e) {
                console.error("Invalid URL format");
                return;
            }

            if (!videoId && !listId) {
                if (startSeconds === 0 && startListIndex === 0) alert("Could not parse YouTube URL."); // Only alert on manual load
                return;
            }

            // Check if YouTube API is loaded
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
                console.log("YouTube API not ready yet, will retry...");
                setTimeout(() => loadYoutube(url, startSeconds, startListIndex), 500);
                return;
            }

            ytContainer.classList.remove('hidden');
            const playerVars = { 'playsinline': 1, 'controls': 0, 'showinfo': 0, 'rel': 0, 'autoplay': 1, 'mute': 0, 'loop': 1, 'origin': window.location.origin };
            if (videoId && !listId) playerVars.playlist = videoId;
            if (startSeconds) playerVars.start = Math.floor(startSeconds);
            if (startListIndex) playerVars.index = startListIndex;

            if (!state.ytPlayer) {
                state.ytPlayer = new YT.Player('yt-player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId || undefined,
                    playerVars: playerVars,
                    events: {
                        'onReady': (event) => {
                            event.target.setVolume(parseFloat(document.getElementById('vol-tv').value) * 100);
                            if (listId) event.target.loadPlaylist({ list: listId, listType: 'playlist', index: startListIndex, startSeconds: startSeconds });
                            else if (startSeconds > 0) event.target.seekTo(startSeconds, true);
                        },
                        'onStateChange': onPlayerStateChange,
                        'onError': onPlayerError
                    }
                });
            } else {
                if (listId) state.ytPlayer.loadPlaylist({ list: listId, listType: 'playlist', index: startListIndex, startSeconds: startSeconds });
                else {
                    state.ytPlayer.loadVideoById(videoId);
                    if (startSeconds > 0) state.ytPlayer.seekTo(startSeconds, true);
                }
            }
        }

        document.getElementById('yt-load-btn').addEventListener('click', () => {
            const url = document.getElementById('yt-url').value;
            loadYoutube(url);
        });


        // --- Video Handling (File) ---
        document.getElementById('room-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                currentRoomFile = file; // Capture for saving
                const url = URL.createObjectURL(file);

                // Determine type
                if (file.type.startsWith('image/')) {
                    state.roomMediaType = 'image';
                    roomImage.src = url;
                    roomImage.onload = () => {
                        roomCanvas.width = roomImage.naturalWidth;
                        roomCanvas.height = roomImage.naturalHeight;
                        staticCanvas.width = roomCanvas.width;
                        staticCanvas.height = roomCanvas.height;

                        state.roomVideoPath = null;
                        document.getElementById('start-overlay').classList.add('hidden');
                        requestAnimationFrame(processFrame);
                    };
                } else {
                    state.roomMediaType = 'video';
                    if (roomVideo.src) URL.revokeObjectURL(roomVideo.src);
                    roomVideo.src = url;
                    roomVideo.onloadedmetadata = () => {
                        roomCanvas.width = roomVideo.videoWidth;
                        roomCanvas.height = roomVideo.videoHeight;
                        staticCanvas.width = roomCanvas.width;
                        staticCanvas.height = roomCanvas.height;
                    };
                    roomVideo.play();
                    state.roomVideoPath = null; // Cleared on manual upload
                    document.getElementById('start-overlay').classList.add('hidden');
                    requestAnimationFrame(processFrame);
                }
                e.target.value = null;
            }
        });

        document.getElementById('tv-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                tvVideo.src = url;
                tvVideo.classList.remove('hidden');
                tvVideo.volume = document.getElementById('vol-tv').value;
                tvVideo.play().catch(e => console.log("Auto-play prevented"));

                if (state.audioContext && state.audioContext.state === 'suspended') {
                    state.audioContext.resume();
                }
            } else {
                unloadTV();
            }
        });

        // --- Unified Video Controls (handled by Remote Control buttons) ---
        // Note: Play/Pause/Unload are handled by remote-play, remote-pause, and remote-eject buttons

        function unloadTV() {
            if (state.tvSource === 'file') {
                tvVideo.pause();
                tvVideo.removeAttribute('src');
                tvVideo.classList.add('hidden');
                document.getElementById('tv-upload').value = "";
            } else if (state.tvSource === 'game') {
                // Clear emulator - Robust Cleanup
                try {
                    console.log("Unloading emulator...");

                    // 1. Try generic Emscripten cleanup if Module exists
                    // This is the most common cause of "ghost" loops keeping the CPU busy
                    if (window.Module) {
                        if (typeof window.Module.pauseMainLoop === 'function') {
                            window.Module.pauseMainLoop();
                        }
                        if (typeof window.Module.abort === 'function') {
                            try { window.Module.abort(); } catch (e) { } // Abort often throws, that's expected
                        }
                    }

                    // 2. Try official destroy/stop methods
                    if (window.EJS_emulator) {
                        if (typeof window.EJS_emulator.destroy === 'function') window.EJS_emulator.destroy();
                        else if (typeof window.EJS_emulator.stop === 'function') window.EJS_emulator.stop();
                        else if (typeof window.EJS_emulator.pause === 'function') window.EJS_emulator.pause();
                    }

                    // 3. Clear the DOM container explicitly
                    const gameDiv = document.getElementById('game');
                    // Remove listeners if possible (cloning replaces the node without listeners)
                    const newGameDiv = gameDiv.cloneNode(false);
                    gameDiv.replaceWith(newGameDiv);

                    // 4. Clear Globals 
                    window.EJS_emulator = null;
                    window.EJS_player = null;
                    window.EJS_core = null;
                    window.EJS_gameUrl = null;
                    window.EJS_volume = 1.0;
                    window.Module = null; // Detach Emscripten module

                    // 5. Revoke Blob URL
                    if (state.emulator && state.emulator.romUrl) {
                        URL.revokeObjectURL(state.emulator.romUrl);
                    }
                } catch (e) {
                    console.error('Error clearing emulator:', e);
                }

                state.emulator = null;
                emulatorContainer.classList.add('hidden');
                state.gameFile = null;
                state.gameSystem = '';
                document.getElementById('rom-upload').value = "";
                document.getElementById('game-system').value = "";
                romFilenameDisplay.textContent = "No ROM loaded";
                romFilenameDisplay.classList.remove('text-green-400');
                romFilenameDisplay.classList.add('text-gray-500');
                updateGameLoadButton();
            } else {
                if (state.ytPlayer && state.ytPlayer.stopVideo) state.ytPlayer.stopVideo();
                ytContainer.classList.add('hidden');
                document.getElementById('yt-url').value = "";
            }
        }

        // --- Audio Volume & Sync ---
        function updateVolume(type, val, source) {
            // Update State
            if (type === 'tv') {
                // TV Handling
                tvVideo.volume = val;
                if (state.ytPlayer && state.ytPlayer.setVolume) state.ytPlayer.setVolume(val * 100);

                // EmulatorJS volume control
                if (state.tvSource === 'game') {
                    try {
                        // Try various methods to update volume dynamically
                        if (window.EJS_emulator && typeof window.EJS_emulator.setVolume === 'function') {
                            window.EJS_emulator.setVolume(val);
                        } else if (typeof window.EJS_setVolume === 'function') {
                            window.EJS_setVolume(val);
                        } else if (window.EJS_player && typeof window.EJS_player.setVolume === 'function') {
                            window.EJS_player.setVolume(val);
                        }

                        // Also update global for robustness
                        window.EJS_volume = val;
                    } catch (e) {
                        // Silent fail if emulator not ready
                    }
                }
            } else {
                // Audio Context Handling
                state.audio[type].vol = val;
            }

            // Sync UI
            const percentage = Math.round(val * 100);
            if (source !== 'slider') {
                // Update slider: TV uses 0-1, audio mixer uses 0-100
                const sliderValue = type === 'tv' ? val : val * 100;
                document.getElementById(`vol-${type}`).value = sliderValue;
            }
            if (source !== 'number') {
                document.getElementById(`vol-${type}-num`).value = percentage;
            }
        }

        // Bind Volume Controls (Slider + Number)
        ['tv', 'birds', 'car', 'mower', 'house'].forEach(type => {
            const slider = document.getElementById(`vol-${type}`);
            const numInput = document.getElementById(`vol-${type}-num`);

            slider.addEventListener('input', (e) => {
                // TV slider is 0-1, audio mixer sliders are 0-100
                const val = type === 'tv' ? parseFloat(e.target.value) : parseFloat(e.target.value) / 100;
                updateVolume(type, val, 'slider');
            });
            numInput.addEventListener('input', (e) => {
                let val = parseInt(e.target.value);
                if (isNaN(val)) val = 0;
                if (val > 100) val = 100;
                if (val < 0) val = 0;
                updateVolume(type, val / 100, 'number');
            });
        });


        // --- Chroma Key Processing ---
        const updateChromaVal = (id, val) => document.getElementById(id).innerText = val;

        document.getElementById('chroma-threshold').addEventListener('input', (e) => {
            state.chroma.threshold = parseInt(e.target.value);
            updateChromaVal('val-chroma-thresh', e.target.value);
        });
        document.getElementById('chroma-softness').addEventListener('input', (e) => {
            state.chroma.softness = parseInt(e.target.value);
            updateChromaVal('val-chroma-soft', e.target.value);
        });

        let frameCount = 0;
        function processFrame() {
            // Optimization: Throttle frame rate to save CPU
            // If gaming, throttle more aggressively (e.g., render 1 every 3 frames -> 20fps background)
            // If normal, render 1 every 2 frames -> 30fps background (sufficient for room vibe)
            frameCount++;
            const skipFrames = state.tvSource === 'game' ? 3 : 2;

            if (frameCount % skipFrames !== 0) {
                requestAnimationFrame(processFrame);
                return;
            }

            // If video, check paused. If image, always draw.
            if (state.roomMediaType === 'video') {
                if (roomVideo.paused || roomVideo.ended) {
                    requestAnimationFrame(processFrame);
                    return;
                }
                ctx.drawImage(roomVideo, 0, 0, roomCanvas.width, roomCanvas.height);
            } else {
                if (roomImage.complete) {
                    ctx.drawImage(roomImage, 0, 0, roomCanvas.width, roomCanvas.height);
                }
            }

            if (state.method === 'chroma') {
                const frame = ctx.getImageData(0, 0, roomCanvas.width, roomCanvas.height);
                const data = frame.data;
                const l = data.length;
                const threshold = state.chroma.threshold;
                const softness = state.chroma.softness;

                for (let i = 0; i < l; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    if (g > r && g > b) {
                        const maxRB = Math.max(r, b);
                        const difference = g - maxRB;

                        if (difference > threshold) {
                            data[i + 3] = 0;
                        } else if (difference > threshold - softness) {
                            const alpha = 1 - ((difference - (threshold - softness)) / softness);
                            data[i + 3] = alpha * 255;
                        }
                    }
                }
                ctx.putImageData(frame, 0, 0);
            }

            // Draw static logic
            let showStatic = false;
            if (state.tvSource === 'file') {
                if (tvVideo.paused || tvVideo.classList.contains('hidden') || !tvVideo.src) showStatic = true;
            } else if (state.tvSource === 'game') {
                // Show static if no emulator is loaded
                if (!state.emulator || emulatorContainer.classList.contains('hidden')) showStatic = true;
            } else {
                // For YouTube, checking playback state is async, so we mostly rely on visibility
                if (ytContainer.classList.contains('hidden')) showStatic = true;
            }

            if (showStatic) {
                drawStatic();
            }

            requestAnimationFrame(processFrame);
        }

        function drawStatic() {
            const w = staticCanvas.width;
            const h = staticCanvas.height;
            const idata = staticCtx.createImageData(w, h);
            const buffer32 = new Uint32Array(idata.data.buffer);
            const len = buffer32.length;

            for (let i = 0; i < len; i++) {
                if (Math.random() < 0.5) {
                    buffer32[i] = 0xff000000;
                } else {
                    const gray = Math.random() * 255;
                    buffer32[i] = (255 << 24) | (gray << 16) | (gray << 8) | gray;
                }
            }
            staticCtx.putImageData(idata, 0, 0);
        }

        // --- TV Transform Controls ---
        const updateTVTransform = () => {
            if (state.method !== 'chroma') return;
            const { scale, rotate, x, y } = state.tvTransform;
            tvWrapper.style.transform = `translate(${x}%, ${y}%) rotate(${rotate}deg) scale(${scale})`;
        };

        document.getElementById('tv-scale').addEventListener('input', (e) => { state.tvTransform.scale = e.target.value; updateTVTransform(); });
        document.getElementById('tv-rotate').addEventListener('input', (e) => { state.tvTransform.rotate = e.target.value; updateTVTransform(); });
        document.getElementById('tv-x').addEventListener('input', (e) => { state.tvTransform.x = e.target.value; updateTVTransform(); });
        document.getElementById('tv-y').addEventListener('input', (e) => { state.tvTransform.y = e.target.value; updateTVTransform(); });

        // --- Audio System ---


        function createNoiseBuffer() {
            const bufferSize = state.audioContext.sampleRate * 2;
            const buffer = state.audioContext.createBuffer(1, bufferSize, state.audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        let noiseBuffer = null;

        function startAudioLoop() {
            if (!noiseBuffer) noiseBuffer = createNoiseBuffer();

            // Load defaults
            loadDefaultSound('mower', 'lawnmower.mp3');
            loadDefaultSound('house', 'talking.mp3');
            loadDefaultSound('birds', 'birds.mp3');
            loadDefaultSound('car', 'traffic.mp3');

            updateLoopSound('mower');
            updateLoopSound('house');
            updateLoopSound('birds');
            updateLoopSound('car');

            // ... intervals ...

            setInterval(() => {
                if (state.audio.car.active && !state.audio.car.buffer && Math.random() < state.audio.car.freq * 0.1) playCarSynth();
            }, 1000);

            setInterval(() => {
                if (state.audio.birds.active && !state.audio.birds.buffer && Math.random() < state.audio.birds.freq * 0.3) playBirdSynth();
            }, 500);
        }

        const handleAudioUpload = (type, e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!state.audioContext) {
                alert("Please click 'START AUDIO' first.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (ev) {
                state.audioContext.decodeAudioData(ev.target.result, function (buffer) {
                    state.audio[type].buffer = buffer;
                    updateLoopSound(type);

                    const synthDiv = document.getElementById('synth-' + type);
                    if (synthDiv) synthDiv.classList.add('hidden-ctrl');

                    const label = e.target.previousElementSibling;
                    if (!label.innerHTML.includes('Active')) {
                        label.innerHTML += ' <span class="text-green-500 text-xs">(MP3 Active)</span>';
                    }
                });
            };
            reader.readAsArrayBuffer(file);
        };

        ['birds', 'car', 'mower', 'house'].forEach(t => {
            document.getElementById('file-' + t).addEventListener('change', (e) => handleAudioUpload(t, e));
        });

        // --- Sound Generation Logic ---

        function updateLoopSound(type) {
            const ctx = state.audioContext;
            if (!ctx) return;
            const soundObj = state.audio[type];

            if (soundObj.buffer) {
                if (soundObj.active && !soundObj.customNode) {
                    const src = ctx.createBufferSource();
                    src.buffer = soundObj.buffer;
                    src.loop = true;
                    const gain = ctx.createGain();
                    src.connect(gain);
                    gain.connect(ctx.destination);
                    src.start();
                    soundObj.customNode = { src, gain };
                } else if (!soundObj.active && soundObj.customNode) {
                    soundObj.customNode.src.stop();
                    soundObj.customNode = null;
                }
                if (soundObj.customNode) {
                    soundObj.customNode.gain.gain.setTargetAtTime(soundObj.vol, ctx.currentTime, 0.1);
                }
                // Low frequency update is fine for volume changes
                setTimeout(() => updateLoopSound(type), 250);
                return;
            }

            if (type === 'birds' || type === 'car') return;

            if (type === 'mower') updateMowerSynth();
            if (type === 'house') updateHouseSynth();

            setTimeout(() => updateLoopSound(type), 250);
        }

        function loadDefaultSound(type, filename) {
            if (!state.audioContext) return;
            fetch('./sounds/' + filename)
                .then(res => {
                    if (!res.ok) throw new Error("No " + filename);
                    return res.arrayBuffer();
                })
                .then(buf => state.audioContext.decodeAudioData(buf))
                .then(buffer => {
                    console.log("Loaded default: " + filename);
                    state.audio[type].buffer = buffer;
                    updateLoopSound(type); // Ensure it starts if active
                    // Hide synths
                    const synthDiv = document.getElementById('synth-' + type);
                    if (synthDiv) synthDiv.classList.add('hidden-ctrl');
                })
                .catch(e => console.log("Default sound skipped: " + filename));
        }

        function playBirdSynth() {
            const ctx = state.audioContext;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const baseFreq = 2000 + Math.random() * 3000;
            osc.type = 'sine';
            osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(baseFreq + (Math.random() * 1000 - 500), ctx.currentTime + 0.1);
            const volume = state.audio.birds.vol * state.audio.birds.int;
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1 + (Math.random() * 0.1));
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.3);
        }

        function playCarSynth() {
            const ctx = state.audioContext;
            const src = ctx.createBufferSource();
            src.buffer = noiseBuffer;
            src.loop = true;
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 5;
            const gain = ctx.createGain();
            const pan = ctx.createStereoPanner();
            pan.pan.setValueAtTime(-1, ctx.currentTime);
            pan.pan.linearRampToValueAtTime(1, ctx.currentTime + 4);
            filter.frequency.setValueAtTime(100, ctx.currentTime);
            filter.frequency.linearRampToValueAtTime(400, ctx.currentTime + 2);
            filter.frequency.linearRampToValueAtTime(100, ctx.currentTime + 4);
            const vol = state.audio.car.vol;
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(vol, ctx.currentTime + 2);
            gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 4);
            src.connect(filter);
            filter.connect(gain);
            gain.connect(pan);
            pan.connect(ctx.destination);
            src.start();
            src.stop(ctx.currentTime + 4.1);
        }

        let mowerOsc = null;
        function updateMowerSynth() {
            const ctx = state.audioContext;
            const soundObj = state.audio.mower;

            if (soundObj.active && !mowerOsc) {
                mowerOsc = ctx.createOscillator();
                mowerOsc.type = 'sawtooth';
                mowerOsc.frequency.value = 60;
                const gain = ctx.createGain();

                const nSrc = ctx.createBufferSource();
                nSrc.buffer = noiseBuffer;
                nSrc.loop = true;
                const nGain = ctx.createGain();
                nSrc.connect(nGain);
                nGain.connect(gain);
                nSrc.start();

                mowerOsc.connect(gain);

                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                gain.connect(filter);
                filter.connect(ctx.destination);

                mowerOsc.start();
                soundObj.instance = { osc: mowerOsc, gain: gain, filter: filter, nSrc: nSrc };
            } else if (!soundObj.active && mowerOsc) {
                mowerOsc.stop();
                soundObj.instance.nSrc.stop();
                mowerOsc = null;
            }
            if (mowerOsc) {
                soundObj.instance.gain.gain.setTargetAtTime(soundObj.vol * 0.3, ctx.currentTime, 0.1);
                const freq = 100 + (soundObj.dist * 500);
                soundObj.instance.filter.frequency.setTargetAtTime(freq, ctx.currentTime, 0.1);
            }
        }

        let houseNode = null;
        function updateHouseSynth() {
            const ctx = state.audioContext;
            const soundObj = state.audio.house;

            if (soundObj.active && !houseNode) {
                const src = ctx.createBufferSource();
                src.buffer = noiseBuffer;
                src.loop = true;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 60;
                const gain = ctx.createGain();
                src.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                src.start();
                houseNode = { src, gain };
            } else if (!soundObj.active && houseNode) {
                houseNode.src.stop();
                houseNode = null;
            }
            if (houseNode) houseNode.gain.gain.setTargetAtTime(soundObj.vol * 0.15, ctx.currentTime, 0.5);
        }

        // Binding Helper
        const bindAudio = (type, param, elementId) => {
            const el = document.getElementById(elementId);
            if (el) el.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                // All bound audio parameters (vol, freq, int, dist) for effects are 0-1 normalized
                // Inputs are 0-100
                state.audio[type][param] = val / 100;
            });
        };
        const bindToggle = (type, btnId) => {
            document.getElementById(btnId).addEventListener('click', (e) => {
                state.audio[type].active = !state.audio[type].active;
                e.currentTarget.classList.toggle('active');
            });
        };

        bindToggle('birds', 'btn-birds');
        bindAudio('birds', 'freq', 'freq-birds');
        bindAudio('birds', 'int', 'int-birds');
        bindToggle('car', 'btn-car');
        bindAudio('car', 'freq', 'freq-car');
        bindToggle('mower', 'btn-mower');
        bindAudio('mower', 'dist', 'dist-mower');
        bindToggle('house', 'btn-house');

        // --- Visual Effects Logic ---
        const crtOverlayScreen = document.getElementById('crt-overlay-screen');
        const crtOverlayTV = document.getElementById('crt-overlay-tv');
        const crtBtn = document.getElementById('btn-crt');
        const crtIntSlider = document.getElementById('crt-intensity');

        // Scope Toggles
        document.getElementsByName('crt-scope').forEach(radio => {
            radio.addEventListener('change', (e) => {
                state.effects.crt.scope = e.target.value;
                updateCRTUI();
            });
        });

        // CRT Toggle
        crtBtn.addEventListener('click', (e) => {
            state.effects.crt.enabled = !state.effects.crt.enabled;
            updateCRTUI();
        });

        crtIntSlider.addEventListener('input', (e) => {
            state.effects.crt.intensity = parseFloat(e.target.value);
            document.getElementById('val-crt-int').innerText = Math.round(state.effects.crt.intensity * 100) + '%';
            if (state.effects.crt.enabled) {
                const target = state.effects.crt.scope === 'screen' ? crtOverlayScreen : crtOverlayTV;
                target.style.opacity = state.effects.crt.intensity;
            }
        });

        function updateCRTUI() {
            const { enabled, intensity, scope } = state.effects.crt;
            const activeScope = scope || 'screen';

            // Sync UI
            const rb = document.querySelector(`input[name="crt-scope"][value="${activeScope}"]`);
            if (rb) rb.checked = true;

            if (enabled) {
                crtBtn.classList.add('active');
                if (activeScope === 'screen') {
                    crtOverlayScreen.style.display = 'block';
                    crtOverlayScreen.style.opacity = intensity;
                    crtOverlayTV.style.display = 'none';
                } else {
                    crtOverlayScreen.style.display = 'none';
                    crtOverlayTV.classList.remove('hidden');
                    crtOverlayTV.style.display = 'block';
                    crtOverlayTV.style.opacity = intensity;
                }
            } else {
                crtBtn.classList.remove('active');
                crtOverlayScreen.style.display = 'none';
                crtOverlayTV.style.display = 'none';
            }
        }

        // TV Effects
        const applyTVEffects = () => {
            const { brightness, contrast, saturation, hue, blur, sepia } = state.effects.tv;
            const filterString = `brightness(${brightness}) contrast(${contrast}) saturate(${saturation}) hue-rotate(${hue}deg) blur(${blur}px) sepia(${sepia})`;
            document.getElementById('tv-transform-wrapper').style.filter = filterString;
        };

        ['bright', 'contrast', 'sat', 'hue', 'blur', 'sepia'].forEach(fx => {
            document.getElementById(`fx-${fx}`).addEventListener('input', (e) => {
                const key = fx === 'sat' ? 'saturation' : (fx === 'bright' ? 'brightness' : fx);
                state.effects.tv[key] = parseFloat(e.target.value);
                applyTVEffects();
            });
        });

        document.getElementById('reset-fx').addEventListener('click', () => {
            state.effects.tv = { brightness: 1, contrast: 1, saturation: 1, hue: 0, blur: 0, sepia: 0 };
            // Update UI inputs
            document.getElementById('fx-bright').value = 1;
            document.getElementById('fx-contrast').value = 1;
            document.getElementById('fx-sat').value = 1;
            document.getElementById('fx-hue').value = 0;
            document.getElementById('fx-blur').value = 0;
            document.getElementById('fx-sepia').value = 0;
            applyTVEffects();
        });

        // Init
        setRatio('16:9');
        drawStatic();

        // --- Config Handling ---
        const saveBtn = document.getElementById('save-config-btn');

        saveBtn.addEventListener('click', () => {
            saveConfig();
        });

        function saveConfig() {
            const performSave = () => {
                // Get YouTube state if available
                let ytState = { url: (document.getElementById('yt-url') ? document.getElementById('yt-url').value : ''), index: 0, time: 0 };
                if (state.ytPlayer && typeof state.ytPlayer.getCurrentTime === 'function') {
                    ytState.time = state.ytPlayer.getCurrentTime();
                    if (typeof state.ytPlayer.getPlaylistIndex === 'function') {
                        ytState.index = state.ytPlayer.getPlaylistIndex();
                    }
                }

                const config = {
                    roomVideoPath: state.roomVideoPath,
                    roomMediaType: state.roomMediaType,
                    method: state.method,
                    tvSource: state.tvSource,
                    ytState: ytState,
                    effects: state.effects,
                    chroma: state.chroma,
                    tvTransform: state.tvTransform,
                    manualSelection: state.manualSelection,
                    audio: {
                        birds: { active: state.audio.birds.active, vol: state.audio.birds.vol, freq: state.audio.birds.freq, int: state.audio.birds.int },
                        car: { active: state.audio.car.active, vol: state.audio.car.vol, freq: state.audio.car.freq },
                        mower: { active: state.audio.mower.active, vol: state.audio.mower.vol, dist: state.audio.mower.dist },
                        house: { active: state.audio.house.active, vol: state.audio.house.vol },
                        tvVol: (document.getElementById('vol-tv') ? document.getElementById('vol-tv').value : 1)
                    },
                    // New Saved States
                    menuState: {
                        sidebarHidden: document.getElementById('sidebar').classList.contains('hidden-panel'),
                        remoteVisible: document.getElementById('remote-panel').classList.contains('visible-panel')
                    },
                    adState: {
                        enabled: state.ads.enabled,
                        adsPerBreak: state.ads.adsPerBreak,
                        playCounts: state.ads.videoPlayCounts
                    },
                    lockedManual: state.lockedManual || false,
                    lastWebUrl: document.getElementById('web-url') ? document.getElementById('web-url').value : ''
                };

                fetch('/api/config/default', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            saveBtn.innerText = "SAVED!";
                            saveBtn.classList.remove('bg-blue-900', 'hover:bg-blue-700');
                            saveBtn.classList.add('bg-green-700', 'hover:bg-green-600');
                            setTimeout(() => {
                                saveBtn.innerText = "SAVE CONFIG";
                                saveBtn.classList.add('bg-blue-900', 'hover:bg-blue-700');
                                saveBtn.classList.remove('bg-green-700', 'hover:bg-green-600');
                            }, 2000);
                        }
                    })
                    .catch(err => {
                        console.error("Save failed", err);
                        alert("Error saving config");
                    });
            };

            // Check if we need to upload currentRoomFile
            if (currentRoomFile) {
                const originalText = saveBtn.innerText;
                saveBtn.innerText = "UPLOADING...";
                const fd = new FormData();
                fd.append('background', currentRoomFile);

                fetch('/api/upload-background', {
                    method: 'POST',
                    body: fd
                })
                    .then(res => res.json())
                    .then(data => {
                        if (data.success) {
                            state.roomVideoPath = data.path;
                            // Keep type sync
                            if (data.type) state.roomMediaType = data.type;

                            currentRoomFile = null; // Mark handled
                            performSave();
                        } else {
                            alert("Background upload failed: " + (data.error || "Unknown"));
                            saveBtn.innerText = originalText;
                        }
                    })
                    .catch(e => {
                        console.error("Upload error", e);
                        alert("Upload error");
                        saveBtn.innerText = originalText;
                    });
            } else {
                performSave();
            }
        }

        // Create a dedicated audio context button listener
        const audioInitBtn = document.getElementById('audio-init');
        if (audioInitBtn) {
            audioInitBtn.addEventListener('click', async () => {
                try {
                    if (!state.audioContext) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        state.audioContext = new AudioContext();
                    }
                    if (state.audioContext.state === 'suspended') {
                        await state.audioContext.resume();
                    }

                    audioInitBtn.innerText = "AUDIO ACTIVE";
                    audioInitBtn.classList.remove('bg-red-900');
                    audioInitBtn.classList.add('bg-green-900');

                    // Ensure global function exists before calling
                    if (typeof startAudioLoop === 'function') {
                        startAudioLoop();
                    } else {
                        console.error("startAudioLoop not defined");
                    }

                    const vid = document.getElementById('tv-video');
                    if (vid && !vid.paused) vid.muted = false;
                } catch (e) {
                    console.error("Audio init error:", e);
                    alert("Audio init failed: " + e.message);
                }
            });
        }

        // --- Ad Management System ---
        function fetchAdConfig() {
            fetch('/ads/config.json')
                .then(res => res.json())
                .then(config => {
                    console.log("Ad Config Loaded:", config);
                    state.ads.config = config;
                    updateAdUI();

                    // Restore play counts from LocalStorage if available
                    const savedCounts = localStorage.getItem('vhs_ad_counts');
                    if (savedCounts) {
                        try {
                            state.ads.videoPlayCounts = JSON.parse(savedCounts);
                        } catch (e) { }
                    }
                })
                .catch(err => console.error("Failed to load ad config", err));
        }

        function updateAdUI() {
            const countInput = document.getElementById('ads-count');
            const playlistCountSpan = document.getElementById('ads-playlist-count');
            const toggleBtn = document.getElementById('btn-ads-toggle');

            if (state.ads.config) {
                const enabledCount = state.ads.config.lists.filter(l => l.enabled).length;
                playlistCountSpan.innerText = enabledCount;
                if (enabledCount > 0 && state.ads.enabled) {
                    toggleBtn.classList.add('active');
                    toggleBtn.style.backgroundColor = '#00ff00';
                } else {
                    toggleBtn.classList.remove('active');
                    toggleBtn.style.backgroundColor = '';
                }
            }

            countInput.value = state.ads.adsPerBreak;

            // Re-bind listener to avoid duplicates if called multiple times (simple check)
            if (!countInput.dataset.bound) {
                countInput.dataset.bound = true;
                countInput.addEventListener('change', (e) => {
                    state.ads.adsPerBreak = parseInt(e.target.value) || 0;
                });
            }
            if (!toggleBtn.dataset.bound) {
                toggleBtn.dataset.bound = true;
                toggleBtn.addEventListener('click', (e) => {
                    state.ads.enabled = !state.ads.enabled;
                    updateAdUI();
                });
            }
        }

        function saveAdCounts() {
            localStorage.setItem('vhs_ad_counts', JSON.stringify(state.ads.videoPlayCounts));
        }

        function resetAdCounts() {
            state.ads.videoPlayCounts = {};
            localStorage.removeItem('vhs_ad_counts');
            console.log(" Ad counts reset");
        }

        // Core Ad Logic
        let currentAdVideoId = null;
        let adBreakStartTime = null;
        let adFailsafeTimeout = null;
        const AD_BREAK_TIMEOUT_MS = 120000;

        function cancelAdBreak() {
            console.log(" Cancelling active Ad Break state.");
            state.ads.isPlayingAd = false;
            state.ads.seekingAd = false;
            state.ads.playCountInBreak = 0;
            state.ads.resumeState = null;

            if (adFailsafeTimeout) {
                clearTimeout(adFailsafeTimeout);
                adFailsafeTimeout = null;
            }
            adBreakStartTime = null;
        }

        function onPlayerStateChange(event) {
            // Ad Optimization Logic (Best Index Selection)
            // Trigger on CUED (-5, often skipped), BUFFERING (3), or UNSTARTED (-1)
            // AND check PLAYING (1) as specific fallback if others missed
            if (state.ads.seekingAd) {
                const triggerStates = [YT.PlayerState.CUED, YT.PlayerState.BUFFERING, YT.PlayerState.UNSTARTED, YT.PlayerState.PLAYING];
                if (triggerStates.includes(event.data)) {
                    // Playlist active?
                    const player = state.ytPlayer;
                    const playlist = player.getPlaylist();

                    // Only proceed if we have a populated playlist to choose from
                    if (playlist && playlist.length > 0) {

                        // Find least played
                        let bestIndex = 0;
                        let minPlays = Infinity;

                        playlist.forEach((vid, idx) => {
                            const count = state.ads.videoPlayCounts[vid] || 0;
                            if (count < minPlays) {
                                minPlays = count;
                                bestIndex = idx;
                            }
                        });

                        console.log(` Selected ad index ${bestIndex} with ${minPlays} plays`);

                        // CRITICAL FIX: Capture the intended Video ID *now*, while we have the playlist.
                        // This ensures that if it errors before playing, we still know which ID failed.
                        if (playlist[bestIndex]) {
                            currentAdVideoId = playlist[bestIndex];
                        }

                        state.ads.seekingAd = false;

                        if (player.getPlaylistIndex() !== bestIndex) {
                            player.playVideoAt(bestIndex);
                        }
                    }
                }
            }

            // Capture Playing Ad ID
            if (event.data === YT.PlayerState.PLAYING && state.ads.isPlayingAd) {
                if (state.ytPlayer && state.ytPlayer.getVideoData) {
                    const data = state.ytPlayer.getVideoData();
                    if (data && data.video_id) {
                        currentAdVideoId = data.video_id;
                    }
                }
            }

            // YT.PlayerState.ENDED = 0
            if (event.data === YT.PlayerState.ENDED) {
                console.log("Video Ended. State:", state.ads);

                if (state.ads.isPlayingAd) {
                    // Ad just finished
                    handleAdFinished();
                } else {
                    // Content just finished

                    // SAFETY CHECK: Prevent Infinite Ad Loops
                    // If the video that just ended belongs to one of our Ad Playlists, 
                    // and we are NOT in 'isPlayingAd' mode, it means the player 
                    // failed to switch back to content. Resurrecting 'finishAdBreak' would be wise,
                    // or just aborting.
                    const player = state.ytPlayer;
                    const currentListId = player.getPlaylistId();

                    const isAdList = state.ads.config && state.ads.config.lists.some(l => {
                        try {
                            const u = new URL(l.url);
                            return u.searchParams.get('list') === currentListId;
                        } catch (e) { return false; }
                    });

                    if (isAdList) {
                        console.warn("Detected Ad Playlist ending while not in Ad Mode. Logic Loop Prevention.");
                        if (state.ads.resumeState && state.ads.resumeState.listId) {
                            console.log("Attempting to force resume...");
                            finishAdBreak();
                        }
                        return;
                    }

                    // Check if we should trigger an ad break
                    const adsValid = state.ads.enabled && state.ads.adsPerBreak > 0 && state.ads.config;
                    const activePlaylists = state.ads.config ? state.ads.config.lists.filter(l => l.enabled) : [];

                    const timeSinceLastAd = Date.now() - (state.ads.lastAdEndTime || 0);
                    const cooldownActive = timeSinceLastAd < 30000;

                    if (cooldownActive && adsValid) {
                        console.log(` Skipping Ad Break (Cooldown: ${Math.round(timeSinceLastAd / 1000)}s/30s)`);
                    }

                    if (adsValid && activePlaylists.length > 0 && !cooldownActive) {
                        // Get current playlist context
                        const playlist = player.getPlaylist();
                        const index = player.getPlaylistIndex();
                        const listId = player.getPlaylistId();

                        if (listId) {
                            state.ads.resumeState = {
                                type: 'playlist',
                                listId: listId,
                                index: index + 1, // Resume at next
                                time: 0
                            };
                            startAdBreak();
                        }
                    }
                }
            }
        }

        function startAdBreak() {
            // Guard: If we are already mid-break, don't restart or clobber resume state
            if (state.ads.isPlayingAd && state.ads.playCountInBreak > 0) {
                console.log(" Ad break already in progress, ignoring duplicate start request.");
                return;
            }

            if (!state.ads.resumeState || !state.ads.resumeState.listId) {
                console.error(" Cannot start ad break - no resume state");
                return;
            }

            console.log(` START AD BREAK (${state.ads.adsPerBreak} ads) | Resume: ${state.ads.resumeState.listId}[${state.ads.resumeState.index}]`);

            state.ads.isPlayingAd = true;
            state.ads.playCountInBreak = 0;
            adBreakStartTime = Date.now();

            // Set failsafe timeout
            if (adFailsafeTimeout) clearTimeout(adFailsafeTimeout);
            adFailsafeTimeout = setTimeout(() => {
                console.error(" AD BREAK TIMEOUT (2min) - forcing resume");
                forceResumeContent();
            }, AD_BREAK_TIMEOUT_MS);

            loadNextAd();
        }

        function loadNextAd() {
            if (state.ads.playCountInBreak >= state.ads.adsPerBreak) {
                finishAdBreak();
                return;
            }

            // Pick a playlist
            const activeLists = state.ads.config.lists.filter(l => l.enabled);
            if (activeLists.length === 0) {
                finishAdBreak();
                return;
            }

            const listConfig = activeLists[Math.floor(Math.random() * activeLists.length)];

            // Extract List ID
            let listId = null;
            try {
                const u = new URL(listConfig.url);
                listId = u.searchParams.get('list');
            } catch (e) { }

            if (!listId) {
                finishAdBreak();
                return;
            }

            console.log("Loading Ad Playlist:", listConfig.name);
            currentAdVideoId = null; // Reset current ID tracking

            state.ytPlayer.loadPlaylist({
                list: listId,
                listType: 'playlist',
                index: 0,
                startSeconds: 0
            });

            state.ads.seekingAd = true;
        }

        function handleAdFinished() {
            state.ads.playCountInBreak++;

            // Track the video that just finished using captured ID
            if (currentAdVideoId) {
                state.ads.videoPlayCounts[currentAdVideoId] = (state.ads.videoPlayCounts[currentAdVideoId] || 0) + 1;
                saveAdCounts();
                console.log("Ad Played (Saved):", currentAdVideoId, "Count:", state.ads.videoPlayCounts[currentAdVideoId]);
            } else {
                console.warn("Could not capture Ad Video ID, count not updated.");
            }

            console.log(` Progress: ${state.ads.playCountInBreak}/${state.ads.adsPerBreak}`);

            if (state.ads.playCountInBreak < state.ads.adsPerBreak) {
                setTimeout(() => loadNextAd(), 500);
            } else {
                finishAdBreak();
            }
        }

        function finishAdBreak() {
            const duration = adBreakStartTime ? ((Date.now() - adBreakStartTime) / 1000).toFixed(1) : '??';
            console.log(` AD BREAK COMPLETE (${duration}s) - Resuming`);

            if (adFailsafeTimeout) {
                clearTimeout(adFailsafeTimeout);
                adFailsafeTimeout = null;
            }

            state.ads.isPlayingAd = false;
            state.ads.seekingAd = false;
            state.ads.lastAdEndTime = Date.now();
            adBreakStartTime = null;

            const resume = state.ads.resumeState;
            if (resume && resume.listId) {
                console.log(` RESUME: ${resume.listId} at index ${resume.index}`);

                // 1s delay ensures clean state transition
                setTimeout(() => {
                    state.ytPlayer.loadPlaylist({
                        list: resume.listId,
                        listType: 'playlist',
                        index: resume.index || 0,
                        startSeconds: 0
                    });
                }, 1000);
            } else {
                console.error(" No resume state!");
            }
        }

        function forceResumeContent() {
            console.warn(" FORCE RESUME triggered");
            state.ads.isPlayingAd = false;
            state.ads.seekingAd = false;
            adBreakStartTime = null;

            if (adFailsafeTimeout) {
                clearTimeout(adFailsafeTimeout);
                adFailsafeTimeout = null;
            }

            const resume = state.ads.resumeState;
            if (resume && resume.listId) {
                state.ytPlayer.loadPlaylist({
                    list: resume.listId,
                    listType: 'playlist',
                    index: resume.index || 0,
                    startSeconds: 0
                });
            }
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);

            if (state.ads.isPlayingAd) {
                console.log("Ad Error encountered. Skipping/Blacklisting ad.");

                // Identify bad ad
                // Identify bad ad
                let badVidId = currentAdVideoId;
                const player = state.ytPlayer;

                // If we don't have the ID, try to get it from the player
                if (!badVidId && player && typeof player.getVideoData === 'function') {
                    try {
                        const d = player.getVideoData();
                        if (d) badVidId = d.video_id;
                    } catch (e) { }
                }

                // fallback: if we still don't have an ID (common with error 150/100), 
                // use the current index to find the ID from the playlist array if available? 
                // Getting the full playlist is hard, but we can try getting the ID from "playlist" array if we had it cached?
                // Better approach: track the index we TRIED to play.
                if (!badVidId && player && typeof player.getPlaylistIndex === 'function') {
                    const badIndex = player.getPlaylistIndex();
                    const playlistIds = player.getPlaylist();
                    if (playlistIds && playlistIds[badIndex]) {
                        badVidId = playlistIds[badIndex];
                        console.log(` Found bad video ID via playlist index ${badIndex}: ${badVidId}`);
                    }
                }

                if (badVidId) {
                    // Mark as "played" (high count) so we don't pick it again for a long time
                    console.log("Blacklisting Bad Ad:", badVidId);
                    state.ads.videoPlayCounts[badVidId] = 9999;
                    saveAdCounts();
                } else {
                    console.warn("Could not identify bad ad ID even with fallback. Skipping slot.");
                }

                state.ads.seekingAd = false;

                // CRITICAL FIX: Increment count so we don't retry forever on the same slot
                state.ads.playCountInBreak++;

                console.log(` Skipped ad (${state.ads.playCountInBreak}/${state.ads.adsPerBreak})`);

                if (state.ads.playCountInBreak < state.ads.adsPerBreak) {
                    setTimeout(() => loadNextAd(), 1000);
                } else {
                    finishAdBreak();
                }

            } else {
                console.log("Content Error encountered. Skipping to next.");
                if (state.ytPlayer && typeof state.ytPlayer.nextVideo === 'function') {
                    state.ytPlayer.nextVideo();
                }
            }
        }

        // Debug helpers (call from browser console)
        window.debugAds = () => {
            console.log(" Ad System State:", {
                enabled: state.ads.enabled,
                adsPerBreak: state.ads.adsPerBreak,
                isPlayingAd: state.ads.isPlayingAd,
                seekingAd: state.ads.seekingAd,
                playCountInBreak: state.ads.playCountInBreak,
                resumeState: state.ads.resumeState,
                trackedVideos: Object.keys(state.ads.videoPlayCounts).length,
                videoCounts: state.ads.videoPlayCounts
            });
        };
        window.resetAds = resetAdCounts;
        window.forceResume = forceResumeContent;

        // Config Loading with careful error handling
        function loadConfig() {
            console.log("Starting loadConfig...");
            fetchAdConfig();
            fetch('/api/config/default')
                .then(res => {
                    if (!res.ok) throw new Error("No config");
                    return res.json();
                })
                .then(config => {
                    console.log("Loading Config:", config);

                    // 1. Restore Room Background
                    state.roomMediaType = config.roomMediaType || 'video';
                    if (config.roomVideoPath) {
                        state.roomVideoPath = config.roomVideoPath;
                        if (state.roomMediaType === 'image') {
                            roomImage.src = config.roomVideoPath;
                            roomImage.onload = () => {
                                roomCanvas.width = roomImage.naturalWidth;
                                roomCanvas.height = roomImage.naturalHeight;
                                staticCanvas.width = roomCanvas.width;
                                staticCanvas.height = roomCanvas.height;

                                document.getElementById('start-overlay').classList.add('hidden');
                                requestAnimationFrame(processFrame);
                            };
                        } else {
                            roomVideo.src = config.roomVideoPath;
                            roomVideo.onloadedmetadata = () => {
                                roomCanvas.width = roomVideo.videoWidth;
                                roomCanvas.height = roomVideo.videoHeight;
                                staticCanvas.width = roomCanvas.width;
                                staticCanvas.height = roomCanvas.height;
                            };
                            roomVideo.play().catch(e => console.log("Auto-play blocked"));
                            document.getElementById('start-overlay').classList.add('hidden');
                            requestAnimationFrame(processFrame);
                        }
                    }

                    // 1.5 Restore Visual Effects
                    if (config.effects) {
                        if (config.effects.crt) state.effects.crt = { ...state.effects.crt, ...config.effects.crt };
                        if (config.effects.tv) state.effects.tv = { ...state.effects.tv, ...config.effects.tv };

                        // Update CRT UI
                        const crtInt = state.effects.crt.intensity;
                        const crtSlider = document.getElementById('crt-intensity');
                        if (crtSlider) crtSlider.value = crtInt;
                        const crtVal = document.getElementById('val-crt-int');
                        if (crtVal) crtVal.innerText = Math.round(crtInt * 100) + '%';

                        if (typeof updateCRTUI === 'function') updateCRTUI();

                        // Update TV FX UI
                        const tv = state.effects.tv;
                        ['bright', 'contrast', 'sat', 'hue', 'blur', 'sepia'].forEach(k => {
                            const el = document.getElementById('fx-' + k);
                            if (el) {
                                const prop = k === 'sat' ? 'saturation' : (k === 'bright' ? 'brightness' : k);
                                el.value = tv[prop] || 0;
                            }
                        });

                        if (typeof applyTVEffects === 'function') applyTVEffects();
                    }

                    // 2. Restore Method & Transform
                    state.method = config.method;
                    state.tvTransform = config.tvTransform || state.tvTransform;
                    state.chroma = config.chroma || state.chroma;
                    state.manualSelection = config.manualSelection || state.manualSelection;
                    state.lockedManual = config.lockedManual || false;

                    // Restore Manual Lock
                    const lockBox = document.getElementById('lock-manual');
                    if (lockBox) {
                        lockBox.checked = state.lockedManual;
                        // Apply UI side effects of lock
                        if (state.lockedManual) {
                            document.getElementById('aspect-container').classList.remove('cursor-crosshair');
                            document.getElementById('manual-hint').classList.add('hidden');
                        }
                    }

                    const methodBtn = document.querySelector(`input[name="place-method"][value="${config.method}"]`);
                    if (methodBtn) {
                        methodBtn.checked = true;
                        if (typeof updateMethodUI === 'function') updateMethodUI();
                    }

                    document.getElementById('chroma-threshold').value = state.chroma.threshold;
                    if (typeof updateChromaVal === 'function') updateChromaVal('val-chroma-thresh', state.chroma.threshold);

                    document.getElementById('chroma-softness').value = state.chroma.softness;
                    if (typeof updateChromaVal === 'function') updateChromaVal('val-chroma-soft', state.chroma.softness);

                    document.getElementById('tv-scale').value = state.tvTransform.scale;
                    document.getElementById('tv-rotate').value = state.tvTransform.rotate;
                    document.getElementById('tv-x').value = state.tvTransform.x;
                    document.getElementById('tv-y').value = state.tvTransform.y;
                    if (typeof updateTVTransform === 'function') updateTVTransform();

                    // 3. Restore Audio
                    if (config.audio) {
                        if (config.audio.tvVol !== undefined && typeof updateVolume === 'function') updateVolume('tv', parseFloat(config.audio.tvVol), 'load');

                        const restoreAudio = (type, data) => {
                            if (!state.audio[type]) return;
                            Object.assign(state.audio[type], data);
                            const volSlider = document.getElementById('vol-' + type);
                            if (volSlider && typeof updateVolume === 'function') {
                                volSlider.value = data.vol * 100;
                                updateVolume(type, data.vol, 'load');
                            }
                            if (data.active) {
                                const btn = document.getElementById('btn-' + type);
                                if (btn) btn.classList.add('active');
                            }
                        };
                        restoreAudio('birds', config.audio.birds);
                        restoreAudio('car', config.audio.car);
                        restoreAudio('mower', config.audio.mower);
                        restoreAudio('house', config.audio.house);

                    }

                    // 4. Restore Menu States
                    if (config.menuState) {
                        const sidebar = document.getElementById('sidebar');
                        const remote = document.getElementById('remote-panel');
                        if (config.menuState.sidebarHidden) sidebar.classList.add('hidden-panel');
                        else sidebar.classList.remove('hidden-panel');

                        // Icon state sync for sidebar
                        const hideMenuBtn = document.getElementById('show-menu-btn');
                        if (config.menuState.sidebarHidden) hideMenuBtn.classList.remove('hidden');
                        else hideMenuBtn.classList.add('hidden');

                        if (config.menuState.remoteVisible) {
                            remote.classList.add('visible-panel');
                            document.getElementById('show-remote-btn').classList.add('hidden');
                        } else {
                            remote.classList.remove('visible-panel');
                            document.getElementById('show-remote-btn').classList.remove('hidden');
                        }
                    }

                    // 5. Restore Ad State
                    if (config.adState) {
                        if (config.adState.enabled !== undefined) state.ads.enabled = config.adState.enabled;
                        if (config.adState.adsPerBreak !== undefined) state.ads.adsPerBreak = config.adState.adsPerBreak;
                        if (config.adState.playCounts) state.ads.videoPlayCounts = config.adState.playCounts;
                        if (typeof updateAdUI === 'function') updateAdUI();
                    }

                    // 6. Restore Web State
                    if (config.lastWebUrl && document.getElementById('web-url')) {
                        document.getElementById('web-url').value = config.lastWebUrl;
                    }

                    // 7. Restore TV Source (Expanded)
                    if (config.tvSource) {
                        state.tvSource = config.tvSource;
                        // Trigger tab clicks
                        let tabId = 'tab-url'; // default
                        if (config.tvSource === 'file') tabId = 'tab-file';
                        else if (config.tvSource === 'game') tabId = 'tab-games';
                        else if (config.tvSource === 'web') tabId = 'tab-web';
                        else if (config.tvSource === 'channels') tabId = 'tab-channels';

                        const tabToClick = document.getElementById(tabId);
                        if (tabToClick) tabToClick.click();

                        if (config.tvSource === 'youtube' && config.ytState && config.ytState.url) {
                            const ytInput = document.getElementById('yt-url');
                            if (ytInput) ytInput.value = config.ytState.url;
                            if (typeof loadYoutube === 'function') loadYoutube(config.ytState.url, config.ytState.time || 0, config.ytState.index || 0);
                        }
                    }

                })
                .catch(err => {
                    console.log("No default config found or error loading, using default.", err);
                    const overlay = document.getElementById('start-overlay');
                    if (overlay) overlay.classList.remove('hidden');
                });
        }

        // Start init
        loadConfig();
    </script>
</body>

</html>